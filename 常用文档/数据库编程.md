# JDBC

- 概念：Java DataBase  Connectivity(java数据库连接)，即使用java语言操作数据库。

- 本质：java官方规定了一套适用所有关系型数据库的规则，即接口。各个数据库软件去实现这套接口，他们提供所谓的**数据库驱动jar包**(封装好了实现类)。java程序员通过==接口编程(JDBC)==，真正执行的代码在驱动jar包里。

  图解：![img](https://i.loli.net/2020/04/19/hsAiepJfTLPKycQ.png)

就是针对接口编程



![image-20210917193036829](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210917193036.png)

> 项目位置 ： `F:\javaSE_workspace\jdbc学习\jdbc_maven` 

---



## 数据库连接池

>  对coon对象进行管理
>
>  项目路径 javase-workspace/jdbc学习 

### 为什么需要连接池？？

首先，看一段jdbc的代码

```
  public static void main(String[] args) throws Exception {

        // 创建连接对象
        String url = "jdbc:mysql://localhost:3306/learn_sql" ;
        String user = "root";
        String password = "123456";
        Connection connection = DriverManager.getConnection(url,user,password);

		// 执行sql语句..... 

		// 销毁连接对象
		connection.close();
```

我们每次都要获取连接对象，才能执行sql语句，执行完了就销毁。

如果sql操作很频繁，这样做是很浪费资源的。

正确的做法是将所有的connection对象放在一个容器中，轮流为sql语句提供服务。

这就是我们学习的连接池的概念。

### 连接池概念

当系统初始化后，容器被创建，容器会申请一些conn对象，当用户需要访问数据库时，从容器中获取conn对象，操作结束后将coon对象归还给容器。

![数据库连接池, websocket - 二号- 博客园](https://images2018.cnblogs.com/blog/1341090/201809/1341090-20180907154623461-1688490853.png)

### DataSource对象

我们从那里获取coon对象呢？？

当当当，那就是DataSource接口。

注意哦，这个接口的实现类由数据库厂商提供驱动实现。

```
Connection conn = dataSource.getConnection();
```

我们只需要上面这行代码就可以获取到conn对象哦.、

下面有两个常用的连接池

Druid ： alibaba提供的连接池技术 （全世界最好的数据库连接池技术哦）

C3P0 : ( 这个没学诶)

### Duird连接池

#### pom.xml

```
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>druid</artifactId>
	<version>1.1.16</version>
</dependency>
```



#### 配置文件：druid.prop

```properties
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://127.0.0.1:3306/db_name
username=root
password=123456
initialSize=5
maxActive=10
maxWait=3000

filters=stat
timeBetweenEvictionRunsMillis=60000
minEvictableIdleTimeMillis=300000
validationQuery=SELECT 1
testWhileIdle=true
testOnBorrow=false
testOnReturn=false
poolPreparedStatements=false
maxPoolPreparedStatementPerConnectionSize=200
```

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3c084fbe-b669-4873-bc6a-f2965927081d/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3c084fbe-b669-4873-bc6a-f2965927081d/Untitled.png)

我之前将配置文件放在 `/java/数据库连接池`  结果in一直是null。

原因在于`DruidDemo.class.getResourceAsStream()`的原理是在编译后的class目录下递归寻找（找不到就到上一级去找）资源，因为**最后被装进内存的是编译后的文件不是源文件！！！**

请务必保证：配置文件最后可以在/classes下找到.

还有路径一定要加`/` ，像这样 `("/druid.properties")` 。

#### Demo

```java
public class DruidDemo {
    public static void main(String[] args) throws Exception {

		// 创建prop对象
        Properties prop = new Properties(); 
        // druid.properties --> in
        InputStream in = DruidDemo.class.getResourceAsStream("/druid.properties");	
        prop.load(in); // in --> prop对象

		// 获取连接池
        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);/

        // 获取连接
        Connection conn = dataSource.getConnection();

				// 归还连接
				conn.close();
				// 连接池提供的conn对象的close()封装了归还对象到连接池的操作，用户不用关心，主要按照之				前的习惯close就行

    }
}
```

#### Utils

> 工具类中通过静态代码块，读配置创建连接池。
>
> 封装了使用方法: getDatabase(),getConn(),close();

```JAVA
/* 
	使用静态成员，静态代码块，实现单例模式
	这个Demo提供了”如何使用工具类实现单例模式“ 的方法
*/

public class JDBCUtils {
    private static DataSource ds;

    // 创建静态成员 ds
    static {
        Properties prop = new Properties();
        InputStream in = DruidDemo.class.getResourceAsStream("/druid.properties");
        try {
            prop.load(in);
            ds = DruidDataSourceFactory.createDataSource(prop);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 获取连接
     */
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }

    /**
     * 释放资源
     */
    public static void close(Statement stmt,Connection coon){
        if (stmt!=null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if (coon!=null){
            try {
                coon.close(); // 归还连接
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    public static void close(ResultSet rs,Statement stmt, Connection coon){
        if (rs!=null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        close(stmt, coon);
    }


    public static DataSource getDaSource(){
        return ds;
    }

}
```

---

### C3P0连接池

#### pom.xml

```
<dependency>
	<groupId>c3p0</groupId>
	<artifactId>c3p0</artifactId>
	<version>0.9.1.2</version>
</dependency>
```

#### 配置文件

- 一般使用c3p0-config.xml配置,也可是c3p0.properties

```XML
<?xml version="1.0" encoding="UTF-8"?>
<c3p0-config>
	<default-config>
		<property name="driverClass">com.mysql.cj.jdbc.Driver</property>
		<property name="jdbcUrl">jdbc:mysql://localhost:3306/learn_c3p0</property>
		<property name="user">root</property>
		<property name="password">123456</property>
		<property name="acquireIncrement">5</property>
		<property name="initialPoolSize">10</property>
		<property name="minPoolSize">5</property>
		<property name="maxPoolSize">20</property>
	</default-config>
	


```

#### 建表

```SQL
CREATE DATABASE learn_c3p0;
USE learn_c3p0;

CREATE TABLE account(
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(40),
	money FLOAT
)CHARACTER SET utf8 COLLATE utf8_general_ci;

INSERT INTO account(NAME,money) VALUES('account1',1000);
INSERT INTO account(NAME,money) VALUES('account2',800);
INSERT INTO account(NAME,money) VALUES('account3',1200);
```

#### 模板

```JAVA
public class C3P0Demo {
    public static void main(String[] args) throws SQLException {

        // 1. 创建数据库连接对象
        DataSource ds = new ComboPooledDataSource();

        // 2. 获取连接对象
        Connection connection = ds.getConnection();

        // 3. print
        System.out.println(connection);
    }
}

```

> 与druid不同，不用我们自己导入配置，原因是ComboPooledDataSource在创建时会去寻找`c3p0-config.xml`，也就是说这个文件的名称是不可以修改的。

#### 工具类

```java
public class C3P0Utils {

    private static ComboPooledDataSource ds = new ComboPooledDataSource();

    public static DataSource getDataSource() {
        return ds;
    }

    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }
}

```

> 只需要创建一个静态ComboPooledDataSource对象；
>
> 没有对于close()的封装。



---

## dbutils

dbutils是对jdbc的封装与jdbcTemplate类似。

> 项目路径 javase-workspace\jdbc学习\dbutils



![image-20210918203614619](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210918203614.png)

### 自定义实现DML



dbassist.java

```JAVA
 public int update(String sql, Object... params) {
        Connection conn = null;
        PreparedStatement psmt = null;

        try {
            // 1. 获取连接
            conn = dataSource.getConnection();
            // 2. 创建PreparedStatement对象
            psmt = conn.prepareStatement(sql);
            // 3. 得到sql语句的元信息(有几个参数,什么类型),判断params与?数量是否一致
            ParameterMetaData parameterMetaData = psmt.getParameterMetaData();
            int parameterCount = parameterMetaData.getParameterCount();
            if (params == null){
                throw new NullPointerException("参数为空");
            }
            if (params.length != parameterCount){
                throw new RuntimeException("希望"+parameterCount+"个参数,但是传入的参数只		``					有"+params.length+"个");
            }
            // 4. 给sql赋值

            for (int i = 0; i < parameterCount; i++) {
                // 通过index确定obj从1开始,数组从0开始
                psmt.setObject(i+1,params[i]);
            }
            // 5. 执行语句
            int res = psmt.executeUpdate();
            // 6. 返回结果
            return res;

        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }finally {
            release(conn,psmt,null);
        }
        return 0;
    }
```

> mysql默认开启自动提交，mybatis session不开启。
>
> 连接池只管理conn。

### 自定义实现DQL

之前的操作到执行语句位置都是一样的,不一样的就是需要封装结果集.

```JAVA
return rsh.handle(rs);
```

BeanHandler

```java
 public T handle(ResultSet rs) {

// 1. 创建实体类对象
T bean = domainClass.newInstance();

// 2. 判断结果集是否为空 rs.next()取出rs集合中的一个对象，如果没有返回null
if (rs.next()) {

	// 3. 根据元信息
	ResultSetMetaData rsMetaData = rs.getMetaData();
	// 循环抽取每一列数据 : 首先获取Bean对象的writeMethod,然后将属性值写入
	for (int i = 0; i < rsMetaData.getColumnCount(); i++) {
		
		//获取每列的name 
		String columnName = rsMetaData.getColumnName(i + 1); // 列从1开始数
		columnName = columnName.toLowerCase(); // 转换为小写
		
		// 获取属性值
		Object propertyValue = rs.getObject(columnName);
		
		// 获取writeMethod() :  需要借助于属性描述器
		PropertyDescriptor pd = new PropertyDescriptor(columnName,domainClass);
		Method writeMethod = pd.getWriteMethod(); // 获取写入数据的方法
		
		// 给对象赋值
		writeMethod.invoke(bean,propertyValue);
	}
}

//4. 返回对象
return bean;


}
```

> 需要注意的是将表格的列名转换为小写,保证列名与属性名一致



> 查询所有dao的实现只需要改变封装结果集的策略;
>
> 即创建一个BeanListHandler实现ResultSetHandler接口

```java
@Override
public List<T> handle(ResultSet rs) {

    List<T> beans = new ArrayList<>();

    try {
        while (rs.next()) {
            // 1. 创建实体类对象
            T bean = domainClass.newInstance();
            ResultSetMetaData rsMetaData = rs.getMetaData();

            // 2. 将rs数据封装到bean中
            for (int i = 0; i < rsMetaData.getColumnCount(); i++) {
                
                String columnName = rsMetaData.getColumnName(i + 1);
                columnName = columnName.toLowerCase();
                PropertyDescriptor pd = new PropertyDescriptor(columnName, domainClass);
                Method writeMethod = pd.getWriteMethod();
                Object propertyValue = rs.getObject(columnName);
                writeMethod.invoke(bean, propertyValue);
            }

            // bean加入集合
            beans.add(bean);
        }
        return beans;


    } catch (SQLException | IntrospectionException | InvocationTargetException | InstantiationException | IllegalAccessException throwables) {
        throwables.printStackTrace();
    }

    return null;
}
```

---

### QueryRunner

- 相当于JDBCTemplate 
- 相当于自定义的DBAssist

如果使用不提供DataSource创建的QueryRunner对象在执行方法是需要提供Conn对象.

如果通过使用连接池就不需要提供Coon对象了.

query()也同样需要一个ResultSetHandler接口的实现类

dbutils包提供了我们之前实现的BeanHandler和BeanListHandler实现类



> 传入datasource,那么每次语句的执行都是独立的事务.
>
> dao每一次调用函数,都会从连接池获取到一个conn,然后执行语句.
>
> 这样每个dao函数之间是独立的,不能实现转账这样需要多条sql,多个dao操作 的 情景.
>
> 所以dbutil提供带conn的方法,这样只要所有操作都使用同一个conn就能保证同步性. 

#### 基本使用

##### maven依赖

```XML
 <dependency>
            <groupId>commons-dbutils</groupId>
            <artifactId>commons-dbutils</artifactId>
            <version>1.7</version>
        </dependency>
```

##### 实现dao

```JAVA
/**
 * @author kkddyz
 *
 * 使用dbutils实现dao
 */
public class AccountDaoImpl implements IAccountDao {


    private QueryRunner queryRunner = new QueryRunner(C3P0Utils.getDataSource());

    @Override
    public void saveAccount(Account account) {
        String saveAccountSql = "insert into account(name,money) values(?,?)";
        String name = account.getName();
        Float money = account.getMoney();
        try {
            queryRunner.update(saveAccountSql, name, money);
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }

    @Override
    public Account findAccountById(Integer id) {

        String sql = "select * from account where id = ?";

        try {
            return queryRunner.query(sql,new BeanHandler<>(Account.class),id);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

    }

    @Override
    public List<Account> findAll() {
        String sql = " select * from account";

        try {
            return queryRunner.query(sql,new BeanListHandler<>(Account.class));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```

> 我很好奇 query是如何判断应该返回T 还是List<T> 它的接口是如何定义的.



## JDBCTemplate

> 1. 实现对CRUD操作的简单封装
> 2. 提供简单的结果集封装
>
> 项目路径 javase-workspace/jdbc学习 



### 出现原因

我们在获取conn对象后，还需要获取statement对象，执行后还需要手动将结果集封装到实体类中很麻烦，能不能将这些操作简化呢？？

基于这些需求Spring的JDBCTemplate 提供的对JDBC的简单封装。

### 创建Tamplate

- 这个对象依赖DataSource对象 -- 通过连接池提供

```
		//配置 数据库连接池
        JdbcTemplate template = null;
        try {
            template = new JdbcTemplate(JDBCUtils.getDaSource());
        } catch (Exception e) {
            e.printStackTrace();
        }
```

### DML操作

update() 操作

```JAVA
public class TemplateDemo1 {
    public static void main(String[] args) {
        // 1. 需要配置 数据库连接
        JdbcTemplate template = null;
        try {
            template = new JdbcTemplate(JDBCUtils.getDaSource());
        } catch (Exception e) {
            e.printStackTrace();
        }

        // 2. 调用方法 templateJDBC内部封装了PreparedStatement
        String update_sql = "update test1 set age = ? where id = ?";
        int test1 = template.update(update_sql,30,1);
        System.out.println(test1); // 返回1 success

        String insert_sql = "insert into test1 (id,age) values (?,?);";
        int test2 = template.update(insert_sql, 4, 18);// 参数化sql查询
        System.out.println(test2);
        
    }
}
```

> 类似的还有insert(),delete()都属于DML,不赘述了。

---

### :star: DQL

---

#### queryForMap

queryForMap() ： 将一条记录封装为Map<String,Object>

```JAVA
	@Test
    public void testQueryForMap() {
        int id = 1;
        String sql = "select * from test1 where id = ?";
        Map<String, Object> stringObjectMap = template.queryForMap(sql, id);
        System.out.println(stringObjectMap);
    }
```

**<font color="red">注意查询到的记录数量只能为1(不然会报错)；</font>**

---

#### queryForList

queryForList() ： 将Map对象装入List容器，用于封装多条记录

```JAVA
  	//我们通过queryForList来实现多条记录的查询
  	@Test
    public void testQueryForList() {
        int age = 20;
        String sql = "select * from test1 where age = ?";
        List<Map<String, Object>> maps = template.queryForList(sql, age);
        for (Map<String, Object> map : maps) {
            System.out.println(map);
        }
    }
```



上面两个都只是将结果集中的数据装入Object对象，而下面会将Obj的数据写入Person对象。

> 插一嘴，这里一开始有个很好笑的念头就是为啥不可以直接将Object对象强转为Person对象；
>
> 原因是，这种想法的前提是，数据库表中的列名和java对象的属性必须完全一样。
>
> 但这是一种尽量应该实现的规范，但是有时无法实现，且也没有办法保证。
>
> 所以，需要通过反射的方式，根据Mapper策略封装属性



---

#### query() 

> 通过RowMapper接口定义封装结果集的实现

##### 手撸RowMapper

```JAVA
public void testQuery() {

    /*
  		query()循环调用RowMapper.mapRow()
 		每次传入一个rs对象，返回一个javaBean对象
  		
    */
    
    // 手写RowMapper接口实现方法
    List<People> peopleList1 = template.query(sql, new RowMapper<People>() {
        @Override
        public People mapRow(ResultSet resultSet, int i) throws SQLException {
            // 创建对象
            People people = new People();
            // 数据 : rs -> java bean 
            people.setId(rs.getInt(1));
            people.setAge(rs.getInt(2));
            // 返回对象到容器
            return people;
        }
    });

```

> 这样写好麻烦, 我们发现只要让table的列与javaBean属性一致就可以通过反射自动实现。
> 那么有没有这样的RowMapper实现类给我们使用呢？？
> 有的 BeanPropertyRowMapper对象通过.class,就可以自动创建对象+抽取rs列到bean中

---

##### BeanPropertyRowMapper

- 自动实现封装
- 前提：保证bean属性与table col一致。

```JAVA
    //泛型，字解码，写一个就行
    List<People> peopleList2 = template.query(sql, new BeanPropertyRowMapper<>(People.class)); 
```

> 注意 ： bean成员不能是基本类型
>
> BeanPropertyRowMapper 对于table中的空值(查询表中得到空值)会装入null,但是基本类型不能接受null，所以Bean类的成员属性必须是对象（包装）。



<font color="blue">此外，queryForObject() : 返回单个对象。</font>



---

### JdbcDaoSupprot

在Ioc配置时，存在重复的代码

```
pricate JbdcTemplate template;

public void setTemplate(JbdcTemplate template){
	this.template = template;
}
```



定义一个父类 JdbcDaoSupport定义注入template的函数

```JAVA
/**
 * @author kkddyz
 *
 * 用于抽取dao中重复的部分: 注入template
 *
 * 通过继承使用这部分代码
 */
public class JdbcDaoSupport {

    /**
     * 直接注入Template
     */
    private JdbcTemplate template;

    public void setTemplate(JdbcTemplate template) {
        this.template = template;
    }

    public JdbcTemplate getTemplate() {
        return template;
    }

    /**
     * 通过datasource创建template
     */
    private DataSource dataSource ;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;

        if (template == null){
            template = createTemplate(dataSource); 
        }

    }

    private JdbcTemplate createTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }


}
```



在使用dao时只需要继承该类，然后再配置中注入template或者datasoure依赖即可

（通过继承得到setDatasource() ）

---

spring中定义好了这个类，当然由于这个类在jar包中无法使用注解实现配置

---

# Mysql

## MYSQL服务器

#### 软件安装 

通过Installer安装  [默认安装教程教程](https://zhuanlan.zhihu.com/p/37152572)

##### 选自定义安装

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210708135011.png" alt="image-20210708135011351" style="zoom:33%;" align="left" />

> 因为默认安装的目录找起来很麻烦；所以需要[自定义安装目录](https://blog.csdn.net/qq_38978315/article/details/104489099)；
>
> 后面和[默认安装](https://zhuanlan.zhihu.com/p/37152572)一样
>
> 1. 安装目录：D:\MySQL\MySQL_Server (不要有空格最好)
>
> 2. 数据目录 ：D:\MySQL\MySQL_Server_Data
>
> 3. 基本信息都能在配置文件my.ini中找到



##### 管理

通过installer程序管理(就放在D盘mysql目录下)

##### 彻底卸载

安装失败，把installer删除后按下面的来

https://www.jianshu.com/p/491f837e434b

#### 打开与关闭服务

1. 启动服务

   `管理员权限：net start mysql80` [^ 1]

2. 关闭服务

   `管理员权限：net stop mysql`80

3. 打开"服务" 手动设定

#### 登录域退出服务

1. 登陆：cmd输入“`mysql -uroot -p`”回车，然后输入设置的root账号的密码`123456`

2. 退出 `exit/quit`

#### 远程登录

- 连接其他主机的mysql服务

  `mysql -h127.0.0.1 -uroot -p` 

---

[^1]: mysql80是安装的时候你起的mysql服务名



mysql安装

#### 查看信息

- 版本

- 直接在操作系统命令行下执行：`MySQL –V` 8.0.19

- 时区

  - ```
    show variables like "%time_zone%";
    ```

<img src="https://i.loli.net/2020/04/18/vOmyhaEuKZ56P8D.png" style="zoom:50%;" align="left" />

- show variables like '%dir%';

  查看基本信息





### 时区问题

1.  [设置时区](https://www.jianshu.com/p/f190650a6c7f)

GMT（Greenwich Mean Time）：格林威治标准时间
UTC：世界标准时间
CST（China Standard Time）：中国标准时间

GMT + 8 = UTC + 8 = CST

#### 报错

##### 1. IDEA 连接报错

<p style="color : red;">Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezone’ property manually.</p>

##### 2.jdbc连接mysql出错

`java.sql.SQLException: The server time zone value ‘XXXXXX’ is unrecognized or represents more than one time zone.`
`You must configure either the server or JDBC driver (via the serverTimezone configuration property)` 
`to use a more specifc time zone value if you want to utilize time zone support.`

#### 原因：

硬件服务器(操作系统)时间和软件服务器时间(mysql服务器时间软件)不一样。

MySQL默认的时区是*UTC(世界标准时间)时区*，比北京时间(系统时区CST)晚8个小时。

#### 解决办法 

修改服务器软件时区设置(硬件时区改不了)

由于 CST = UTC + 8；

- `set global time_zone='+8:00';` // 

- 修改my.ini

  ```mysql
  [mysqld]
  default-time-zone = '+08:00'
  ```

<font color="red">必须重启服务才能更新my.ini的配置，不是重新启动cmd! ! ! ! !</font>

---



#### [安装](https://zhuanlan.zhihu.com/p/82899047) installer程序

#### 删除

卸载也是在installer里进行。别看网上那些杂七杂八的东西。

#### 数据库信息

名称：MySQL80

[修改数据库字符集](https://my.oschina.net/wangt10/blog/508374)

utf8mb4是utf8的超集

---





---

---



## SQL基础

- structure query language 结构化查询语言
- 定义了操作所有**关系型数据库**的规范。但是每种数据库的操作方式与规范存在不一样的地方称为“**方言**”。 



#### SQL通用语法

- 注释
  - 单行：# 或者 -- （两个短横杠+空格）
    - -- 注释；是一种通用注释 #是sql特有的
  - 多行：/* */

#### SQL分类

1. DDL (data definition language) 定义模板

   - 用来定义数据库对象：数据库，表，列；

2. DML(manipulation)  操作模板对象

   - 操作数据库的表中数据

3. DQL (query) 查询

   - 查询操作数据库的表中数据
   
4. DCL (control) 控制

   - 设置数据库的访问权限



#### SQL的数据类型

- 整数类型 ：age int

- 浮点类型：grade double(5,2) # **数共5位，小数点后2位**

- 日期类型：

  - date yyyy--MM--dd #日期 年月日

  - datetime yyyy--MM--dd HH:mm:ss #时间 年月日 时分秒 

  - timestamp 格式同datetime # 时间戳 : 默认值(不赋值||赋值为null) 当前的系统时间

    value = CURRENT_TIMESTAMP;

- 字符串类型:

  - varchar(10)  

    #可变字符串 不超过10个字符(汉字和字母都占一个字符utf8编码)

  - character(10) (character就是char缩写  )# 字符串**固定长度**10

#### 数据库DDL：CRUD

##### C(create )

- 创建不存在的数据库：
  - create database **if not exists** learn_sql;
- 指定字符集字符集
  - create database learn_sql **character set gbk**;

##### R(retreieve)

- 查询所有数据库名称
  - show databases;
- 查询mysql默认的的字符集
  - show variables like 'character%';
- 查询某个数据库的字符集 
  - show create database <database_name>;

##### U(update)

- 修改数据库的字符集
  - **alter** database <database_name>  character set gbk;

##### D(delete)

- **drop** database if exists <database_name>

##### 使用数据库

- 使用数据库 (相当于进入文件夹)
  - use <database_name>
- 查询正在使用的数据库
  - select database();

#### 表DDL ：CRUD

##### C (Create 创建)

![image-20200712121906756](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200712121906.png)

---

##### R (Retrieve 查询)

- 查询数据库的所有表 
  - show tables;
- 查询表的属性
  - show create table <table_name>;
- 查询表**结构**<font color="blue"> 不是内容对象 而是表这个类</font>
  - desc <table_name> # describe 描述这个表
  ![image-20200712115511507](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200712115511.png)

---

---

##### U(Update 修改)

1. 修改表的属性

   - alter table <table_name> rename to <new__name>; 

     #操作类型(alter)+对象(table student) + 具体操作(rename to) + 操作参数 

   - alter table <table_name> character set utf8;

2. 修改表的结构(即列的属性)

   ![image-20200712123655390](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200712123655.png)


##### D(Delete 删除) 

- 删除表
  - drop table if exists <table_name>;



#### DML

```mysql
# 创建表 时间戳得设默认值DEFAULT CURRENT_TIMESTAMP 不然没用 
CREATE TABLE student(
	id INT ,
	NAME VARCHAR(32),
	age INT,
	score DOUBLE(4,1),
	birthdat DATE,
	insert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP           

);
DESC student; 
#DML data manipulation language 操作模板数据


# 添加数据 
INSERT INTO student(id,NAME,age) VALUES(1,"张三",18);
SELECT * FROM student;

# 省略列名 默认values匹配所有列 新的值会覆盖原来CURRENT_TIMESTAMP 
					# 如果你要使用系统时间就不能省略前面的列名
INSERT INTO student VALUES(2,"里斯",18,99.9,"2020-12-12");


# 删除，修改数据都得先找到数据 怎么找?? 其实不是找是删选 就像java里的if条件判断 在sql里就是where

# 删除数据 
DELETE FROM student WHERE id=1; 
SELECT * FROM student;

#如果不加条件 默认删除所有记录 这是因为where语句会逐一检查所有条件对符合条件的记录执行操作
#所以这样效率很低 
#执行truncte语句代替 -- 直接删除表，然后创建一样的空表,以此达到清空的效果；
TRUNCATE TABLE student;

#修改数据
UPDATE student SET age=118 WHERE id=1;
#WHERE后以and连接判断条件
UPDATE student SET age=117 WHERE id=2 AND birthday="2020-12-12";
```

---

#### DQL

##### 语法

```mysql
select 

​	[...字段]

from

​	[...表名]	

where

​	[...条件]

group by

​	[...分组字段]

having

​	[分组之后的条件]

order by

​	[...排序字段]

limit

​	分页限定
```

##### 基础查询

```sql
# 创建成绩表
CREATE TABLE student_score(   
	id INT,  -- 编号   
	NAME VARCHAR(20), -- 姓名   
	age INT, -- 年龄   
	sex VARCHAR(5),  -- 性别   
	address VARCHAR(100),  -- 地址   
	math INT, -- 数学   
	english INT -- 英语 
); 
# 添加数据
INSERT INTO student_score(id,NAME,age,sex,address,math,english) 
VALUES  
	(1,'马云',55,'男', ' 杭州',66,78),
	(2,'马化腾',45,'女','深圳',98,87),
	(3,'马景涛',55,'男','香港',56,77),
	(4,'柳岩 ',20,'女','湖南',76,65),	
	(5,'柳青',20,'男','湖南',86,NULL),
	(6,'刘德华',57,'男','香港 ',99,99),
	(7,'马德',22,'女','香港',99,99),
	(8,'德玛西亚',18,'男','南京',56,65); 
# 最基本的一句查询
SELECT * FROM student_score;

# 查询部分列
SELECT address FROM student_score;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200713200625.png" alt="image-20200713200623957" style="zoom: 80%;" align="left"/>

<font color="blue">我们只想知道这些人来自哪些城市，因此重复出现的城市很碍眼 -- 需要<font color="red">去重</font>。</font>

```mysql
#去除重复的结果集
SELECT DISTINCT address FROM student_score;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200713201154.png" alt="image-20200713201154183" style="zoom:80%;" align="left" />

<font color="blue">假设我想知道他们的总分，但是没有这列有什么办法呢？？</font>

<font color="red">sql允许数据(int,double)计算</font>

```mysql
# 计算
    SELECT NAME,math,english,math+english FROM student_score;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200713201858.png" alt="image-20200713201858477" style="zoom:80%;" align="left"/>

<font color="blue">有null参与的sql运算结果为null(显然不合理)。</font>

<font color="blue">其实null参与运算本身就不合理因此结果为null意思是没有结果；</font>

<font color="blue">如何解决(遇到null特殊处理).</font>

在sql有专门一个ifnull函数用于替换运算中的null值;

```mysql
# 特殊处理NULL 
SELECT NAME,math,english,math+ifnull(english,0) FROM student_score;
# 个人理解: 相当于单目运算符 优先级在+之上,运算时先判断变量english是否为null，ifnull成立对变量赋值，这里是0
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200713202526.png" alt="image-20200713202525979" style="zoom:80%;" align="left"/>

<font color="blue">虽然实现了运算，但是运动结果好长也不便于理解。</font>

```mysql
# 起别名
SELECT NAME,math,english,math+IFNULL(english,0) AS "总分" FROM student_score;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200713203017.png" alt="image-20200713203017555" style="zoom:80%;" align="left"/>

<font color="red">看起来相当完美。</font>

---

- **找到记录**

##### 1. 条件查询

<font color="blue">然后通过一些条件我可查询想要的数据</font>

```mysql
# 限制数据范围 > < = != (sql没有==) 
SELECT * FROM student_score WHERE age>20;

# 20-30 可以用between 20 and 30; (当然用 age>19 and age<31 一样的)
SELECT * FROM student_score WHERE age BETWEEN 20 AND  30;

# null不参与运算(=比较运算) 只能通过is null 判断
SELECT * FROM student_score WHERE english IS NULL;
```

---

<font color="blue">但是这些条件用来处理数据有还可处理字符串就没辙了；</font>
<font color="blue">比如，表中姓马的有哪些你怎么办？？</font>

<font color="red">这时用到模糊查询.</font>

```MYSQL
#模糊查询 占位符: %任意字符串 _任意字符  
#模糊查询用另一种方式(占位符)来实现对字符串的模糊概括；
#相比于正则表达式语法更简单,但使用的范围也窄

```

```mysql
# '马'开头的name
SELECT * FROM student_score WHERE NAME LIKE "马%";
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200713211048.png" alt="image-20200713211048318" style="zoom:80%;" align="left"/>



```MYSQL
# 第二个字是’马‘的name
SELECT * FROM student_score WHERE NAME LIKE "_化%";
```

![image-20200713211551558](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200713211551.png)

```mysql
# 包含'华'的name
SELECT * FROM student_score WHERE NAME LIKE "%华%";
```

---

##### 约束查询结果

##### 2. 排序

```mysql
# 默认升序排列
SELECT * FROM student_score ORDER BY math;

# 通过 asc(ending) desc(ending) 指定升序 降序
SELECT * FROM student_score ORDER BY math ASC;
SELECT * FROM student_score ORDER BY math DESC;
```

---

##### 3.分页

*显示一段记录*

```mysql
#limit a,b; 从第a+1条记录开始，每页显示b条；可以省略a默认从第1条开始

SELECT * FROM student_score LIMIT 3;

#注意：分页是MySQL的方言
```

---

##### 处理查询结果

#####  4. 聚合函数

​	* 计算"整体"记录的数据

```MYSQL
# 聚合函数对列进行纵向计算，计算结果本身作为一条查询记录存在，返回的rs封装为In

## count 统计一列记录数量
SELECT COUNT(NAME) AS "学生个数" FROM student_score;		
### 聚合函数计算排除null 
SELECT COUNT( IFNULL(english,0) ) AS "英语考生" FROM student_score;	
```

```mysql
----------------------------------------------
### java伪代码逻辑
while(hasnext(Name)){
	var value = getNextValue(NAME);
	#IFNULL(english,0);
	if (value == null){
	value = 0;
	}
	#count( IFNULL(english,0) );
	count = 0;
	if (value){
		count++;
	}
}
return count;
```

```mysql
##max,min,avg
SELECT MAX(math) AS "数学最高分",MIN(math) AS "数学最低分",AVG(math) AS "数学平均分" FROM student_score;	
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200714115832.png" alt="image-20200714115831090" style="zoom:80%;" align="left"/>

---

##### 5.分组 

分组是将所有记录集合得到的整体记录是一个特殊的记录，用来表示一组记录的特点；

```mysql
# 分组操作聚合函数
SELECT sex,COUNT(id) AS "人数",AVG(math) AS "数学平均分" FROM student_score GROUP BY sex;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200714162300.png" alt="image-20200714162259846" style="zoom:80%;" align="left"/>

<font color="red">注意 `select A from B` </font>

<font color="red">B是筛选的记录，A是记录的内容 ；</font>

<font color="red">那么可以这么理解 选择来自(student_score GROUP BY sex)组对象的sex,COUNT(id)；</font>

---

###### 筛选组

<font color="blue">既然组可以作为一个图书的记录存在那么如何筛选这条特殊的记录？？</font>

- <font color="red">HAVING [conditions..] </font> 

<font color="blue">既然组记录就是特殊的记录自然可以使用条件筛选不过为了区分使用HAVING代替WHERE</font>

```mysql
SELECT sex,COUNT(id) AS "人数",AVG(math) AS "数学平均分" FROM student_score GROUP BY sex HAVING COUNT(id)>3;
```

---

---



## 基础补充

### 分页

方式一：

```
select * from table order by id limit m, n;
```

该语句的意思为，查询m+n条记录，去掉前m条，返回后n条记录。无疑该查询能够实现分页功能，但是如果**m的值越大，查询的性能会越低**（越后面的页数，查询性能越低），因为MySQL同样需要扫描过m+n条记录。

方式二：

```
select * from table where id > #max_id# order by id limit n;
```

该查询每次会返回n条记录，却无需像方式1扫描过m条记录，在大数据量的分页情况下，性能可以明显好于方式1，但该分页查询必须要每次查询时拿到上一次查 询（上一页）的一个最大id（或最小id）。该查询的问题就在于，我们有时没有办法拿到上一次查询（上一页）的最大id（或最小id），比如当前在第3 页，需要查询第5页的数据，该查询方法便爱莫能助了。

方式三：

为了避免能够实现方式2不能实现的查询，就同样需要使用到limit m, n子句，为了性能，就需要将m的值尽力的小，比如当前在第3页，需要查询第5页，每页10条数据，当前第3页的最大id为#max_id#：

```
 select * from table where id > #max_id# order by id limit 20, 10;
 
```

其实该查询方式是部分解决了方式2的问题，但如果当前在第2页，需要查询第100页或1000页，性能仍然会较差。

方式四：

```
 select * from table as a inner join (select id from table order by id limit m, n) as b on a.id = b.id order by a.id;
```

该查询同方式1一样，m的值可能很大，但由于内部的子查询只扫描了字段id，而不是整张表，所以性能要强于方式1查询，并且该查询能够解决方式2和方式3不能解决的问题。

方式五：

```
 select * from table where id > (select id from table order by id limit m, 1) limit n;
```

该查询方式同方式4，同样通过子查询扫描字段id，效果同方式4。至于性能的话，方式5的性能会略好于方式4，因为方式5不需要在进行表的关联，而是一个简单的比较。





## SQL约束

### 非空，主键，唯一

<font color="blue">概念：对表中数据进行限定，保证数据的正确有效和完整</font>

(听起来有点像表单的检查)

<font color="blue">比如你提交一条记录 name=null,age=18,sex="man";</font>

<font color="blue">显然这样的数据是不完整的，不正确的，无效的；需要被剔除；</font>

<font color="blue">我们需要在对表添加约束条件；</font>

```mysql

# 新建一个学生信息表  添加约束 : 非空，唯一，主键，外键

# 非空约束 NOT NULL
CREATE TABLE student_info(
	id INT,
	NAME VARCHAR(30) NOT NULL-- name非空
);

SELECT * FROM student_info;

INSERT INTO student_info(id,NAME) VALUES (001,"张三丰");
# 这是不允许提交name=null 
INSERT INTO student_info(id,NAME) VALUES (001,NULL);

DROP TABLE student_info;

# 唯一约束 UNIQUE
CREATE TABLE student_info(
	NAME VARCHAR(30),-- name非空
	phone_number VARCHAR(20) UNIQUE -- 电话号码不允许重复
);

INSERT INTO student_info(NAME,phone_number) VALUES("张山","18556041926");
INSERT INTO student_info(NAME,phone_number) VALUES("王五","18556041926"); # deplicate entry 重复录入

DROP TABLE student_info;

# 主键约束

## 什么是主键 -- 一条记录的惟一标识 因此 主键非空且唯一，主键即ID

CREATE TABLE student_info(
	id INT PRIMARY KEY, -- ID 主键
	NAME VARCHAR(30)
);
DESC student_info;

INSERT INTO student_info(id,NAME) VALUES(001,"张山");
INSERT INTO student_info(id,NAME) VALUES(NULL,"张山"); # cannot be null
INSERT INTO student_info(NAME) VALUES("张山");         # dose not has adefault value 
INSERT INTO student_info(id) VALUES(002);              # 主键非空，因此默认的null不行，name却是可以的；
INSERT INTO student_info(id) VALUES(002);              # 重复录入

DROP TABLE student_info;

## 自动增长(AUTO_INCREMENT) 主键值的一般做法 自动生成不重复的ID
CREATE TABLE student_info(
	id INT PRIMARY KEY AUTO_INCREMENT, -- ID 主键 自动增长
	NAME VARCHAR(30)
);

INSERT INTO student_info(NAME) VALUES("张山");
INSERT INTO student_info(NAME) VALUES("李四");
INSERT INTO student_info(NAME) VALUES("王武");
INSERT INTO student_info(id,NAME) VALUES(NULL,"新江");

# 非空约束的检查是在覆盖值以后检查(数据项是否为null)而不是检查覆盖值是否NULL,这样ID default value = auto_increasement 用null覆盖还是 auto_increasement 不影响；
INSERT INTO student_info VALUES(NULL,"夏天"); #主键不需要你赋值但是，如果省略filed必须写上所有对应值(编译要求)
INSERT INTO student_info VALUES(111,"夏天");  #对主键赋值会覆盖自动增长，因此上一条通过null(不赋值，不覆盖)保持
# 自动增长读取上一条记录的主键值++ 
INSERT INTO student_info VALUES(NULL,"春天");

SELECT * FROM student_info;

```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200714201017.png" alt="image-20200714201017439" style="zoom:80%;" align="left"/>

### 外键约束


```MYSQL
# 创建 员工表 
CREATE TABLE employee(
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(20),
	age INT,
	dep_name VARCHAR(20),    -- 部门名称
	dep_location VARCHAR(20) -- 部门地址
);

DESC employee;

INSERT INTO employee(NAME,age,dep_name,dep_location) VALUES("张三",20,"研发部","广州");
INSERT INTO employee(NAME,age,dep_name,dep_location) VALUES("李四",21,"研发部","广州");
INSERT INTO employee(NAME,age,dep_name,dep_location) VALUES("王五",20,"研发部","广州");
INSERT INTO employee(NAME,age,dep_name,dep_location) VALUES("老王",20,"销售部","深圳");
INSERT INTO employee(NAME,age,dep_name,dep_location) VALUES("老王",20,"销售部","深圳");
INSERT INTO employee(NAME,age,dep_name,dep_location) VALUES("小王",18,"销售部","深圳");

SELECT * FROM employee;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200715132617.png" alt="image-20200715132617493" style="zoom:80%;" align="left"/>

这样的表存在一个问题 ：员工与部门属于一对多的关系；这种方式会导致数据冗余和难以维护的问题；

将不同对象的数据拆分，封装入两张表，然后通过外键的方式相关联(组合)，这是面向对象的第一步；

外键的本质是引用

```mysql
# 拆分表 一个员工属于一个部门 员工需要一个部门引用 但是部门不需要引用员工
CREATE TABLE employee(
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(20),
	age INT
);
INSERT INTO employee(NAME,age) VALUES("张三",20);
INSERT INTO employee(NAME,age) VALUES("李四",21);
INSERT INTO employee(NAME,age) VALUES("王五",20);
INSERT INTO employee(NAME,age) VALUES("老王",20);
INSERT INTO employee(NAME,age) VALUES("老王",20);
INSERT INTO employee(NAME,age) VALUES("小王",18);

CREATE TABLE department(
	id INT PRIMARY KEY AUTO_INCREMENT,
	dep_name VARCHAR(20),    -- 部门名称
	dep_location VARCHAR(20) -- 部门地址
);
INSERT INTO department(dep_name,dep_location) VALUES("研发部","广州");
INSERT INTO department(dep_name,dep_location) VALUES("销售部","深圳");

SELECT * FROM employee;
SELECT * FROM department;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200715135244.png" alt="image-20200715135244711" style="zoom:80%;" align="left"/><img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200715135341.png" alt="image-20200715135341519" style="zoom:140%;" align="left"/>























创建外键 

![image-20201224145555841](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20201224145556.png)

- constraint <fk_name> foreign key (this.id) references <that_table>(id)
- 现在dep-id收到一些约束，比如不可以是dep表中不存在的id；

删除外键

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20201224150629.png" alt="image-20201224150628957" style="zoom: 80%;" align="left"/>

添加外键

> 语法:alter table 表名 add constraint FK_ID foreign key(你的外键字段名) REFERENCES 外表表名(对应的表的主键字段名);

### 修改约束

#### 创建

```
如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：

MySQL / SQL Server / Oracle / MS Access：

CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)
)

```







###   级联操作

- ondelete on update是对外键约束的补充：定义了存在依赖关系的情况下的表操作情况

ON DELETE CASCADE 级联删除
ON UPDATE CASCADE 级联更新



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20201224151155.png" alt="image-20201224151155240" style="zoom:50%;" align="left"/>



我希望能够修改dep(父表)的id，然后关联到这个id的所有employee的dep_id自动跟新为5

这时需要设置级联更新

![image-20201224152921494](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20201224152921.png)

添加级联删除后如果dep删除，关联的员工记录也会被删除。

---

### on delete/update详解

On Delete和On Update都有Restrict，No Action, Cascade,Set Null属性。现在分别对他们的属性含义做个解释。

ON DELETE
 restrict(约束):当在父表（即外键的来源表）中删除对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除。

no action:意思同restrict.即如果存在从数据，不允许删除主数据。

cascade(级联):当在父表（即外键的来源表）中删除对应记录时，首先检查该记录是否有对应外键，如果有则也删除外键在子表（即包含外键的表）中的记录。

set null:当在父表（即外键的来源表）中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（不过这就要求该外键允许取null）

ON UPDATE
 restrict(约束):当在父表（即外键的来源表）中更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许更新。

no action:意思同restrict.

cascade(级联):当在父表（即外键的来源表）中更新对应记录时，首先检查该记录是否有对应外键，如果有则也更新外键在子表（即包含外键的表）中的记录。

set null:当在父表（即外键的来源表）中更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（不过这就要求该外键允许取null）。

注：NO ACTION和RESTRICT的区别：只有在及个别的情况下会导致区别，前者是在其他约束的动作之后执行，后者具有最高的优先权执行。



比如现在

## 多表操作

#### 多表关系

1. 多表关系

   1. 分类

      - 一对一

      - 一对多

      - 多对多

   2. 实现方式

      ![image-20210125131825808](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125131825.png)

      

      ![image-20210125132753288](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125132753.png)

      ​		- <font color="blue">id=3记录是非法的因为card.id对应的student.id也是唯一的，这样才是一对一。</font>

      ![ ](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125132425.png)

   3. 实例分析

      ![image-20210125133605589](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125133605.png)




## 三大范式

![image-20210125192307103](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125192307.png)

- NF - normal form



### 1NF

<font color="blue">看下图</font>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125235327.png" alt="image-20210125235327827" style="zoom:80%;" align="left"/>

<font color="blue">这就是违反1NF的一个例子，修改的方法很简单，如下</font>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125235503.png" alt="image-20210125235502947" style="zoom:80%;" align="left"/>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210309123658.JPG" alt="IMG_1905(20210309-123207)" style="zoom:67%;" />



---

### 2NF

#### <font color="red">存在问题</font>

<font color="blue">但是改完后的表有不少问题。主要如下</font>

```
1. 姓名,系名,系主任 存在数据冗余(重复)
2. 系名和系主任应该并不依赖于学生(学号)而存在，是独立的。
	- 举例，当创建一个新的系的时候如果没有对应的学生，那么就没有合法记录出现在当前的表中
	- 另外，当"张无忌"毕业后，这条记录被删除，那么系的信息也会被删除，这显然不合理。
```

<font color="blue">这就需要引入2NF</font>

#### <font color="red">概念分析</font>

1. **函数依赖**：A-->B , 通过A属性(组)的值，可以唯一(<font color="blue">学号相同，分数值不同这种就是不唯一</font>)确定B属性的值
- 比如*学号-->姓名,课程名称,系名,系主任* ，再比如*(学号，课程名称)-->分数* 
2. **完全函数依赖**：A是确定B的最小属性(组)，则称B完全依赖于A

   - 比如*(学号,系名)-->姓名*，就不是完全依赖，而称为**部分函数依赖**(<font color="blue">只依赖于一部分属性</font>)。

3. **传递函数依赖**：A-->B B-->C C依赖于B，B依赖于A，则C传递依赖于A
- *学号-->系名-->系主任*
4. **(候选)码**：该表的所有其他属性完全依赖于A属性(组)

   - 码中的属性称为**主属性**，其余称为**非主属性**。

   - 分析表的属性我们发现：
     - *学号-F->姓名,系主任,系名* 
     - *(学号,课程名称)-P->分数*
     - 即*(学号,课程名称)-P->姓名,系主任,系名,课程名称,分数*,但是并不是完全函数依赖。
     - 这意味着这张表需要<font color="blue">消除</font>*(姓名,系主任,系名)*<font color="blue">对</font>*(学号,课程名称)*<font color="blue">的部分依赖</font>

---

#### <font color="red">消除部分依赖</font>	

将部分依赖的属性和码投影为新表，原表中删除部分依赖的属性

![image-20210126005515041](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126005515.png)

<font color="blue">t_enrolled 自然连接 t_student就可以得到拆分之前的表</font>



拆分后部分数据冗余消除了，但是之前张无忌毕业的问题还是没有解决。



![IMG_1906(20210309-123607)](D:\QQ\QQDATA\2387811469\FileRecv\MobileFile\IMG_1906(20210309-123607).JPG)

---

### 3NF 

- 任何非主属性不依赖于其他非主属性(消除传递依赖)

确实 *学号-->系名,系主任* 但是*系名-->系主任*

我们发先存在 *学号-->系名-->系主任* 这样一个传递依赖关系。



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126020139.png" alt="image-20210126020139406" style="zoom:67%;" align="left"/>

- 这样就解除了学生与系之间的耦合

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210309124729.JPG" alt="IMG_1909(20210309-124410)" style="zoom:67%;" />

---



## 数据库备份与还原

- cmd操作

![image-20210126141741568](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126141741.png)

- 图形界面是一样的流程，略。

---

## 多表查询

 隐式内连接()

- <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126174151.png" alt="image-20210126174151903" style="zoom: 80%;" align="left" />

显示内连接

- <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126173648.png" alt="image-20210126173648427" style="zoom: 67%;" align="left"/>
- 是自然连接的扩展，theta连接

外连接查询

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126174619.png" alt="image-20210126174619305" style="zoom:80%;" align="left"/>



## 子查询



### 引入

有这么一张表:

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126182621.png" alt="image-20210126182621719" style="zoom:80%;" align="left"/>

我们需要查询最高工资员工的信息

一种不太优雅的做法如下：

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126182750.png" alt="image-20210126182750158" style="zoom:80%;" align="left"/> 



合并为一条语句，这就是子查询

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126182904.png" alt="image-20210126182903951" style="zoom:80%;" align="left" />



子查询结果的不同情况

1. 单行单列
   - 作为属性值参与条件运算
   
   ![image-20210808202545984](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210808202547.png)
2. 单列多行(子查询存在多条记录)
   - ![image-20210126200409030](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126200409.png)
3. 多行多列
   - 查询结果作为虚拟表与其他表进行自然连接
   - <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126202306.png" alt="image-20210126202306017" style="zoom:80%;" align="left" />

---



## 事务

1. 概念：

   - 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。

2. 操作

   1. 开启事务：start transaction
   2. 回滚：rollback
   3. 提交：commit

比如,在银行转账这个业务中,要么两个人的账户余额通过修改,要么不修改,不能一个转账,另一个没到账

  ```


-- 创建账户表
CREATE TABLE account(
	a_id INT PRIMARY KEY AUTO_INCREMENT,
	a_name VARCHAR(10),
	a_balance DOUBLE
);

-- bu插入两条记录 
INSERT INTO account (a_name,a_balance) VALUES ('张三',1000) ,('李四',1000);

-- 1. tom转出500
UPDATE account SET a_balance = a_balance - 500 WHERE a_name = 'tom';

-- 2. jerry转入500
UPDATE account SET a_balance = a_balance + 500 WHERE a_name = 'jerry';

SELECT * FROM account; -- tom 500 jerry 1500
-- 还原
UPDATE account SET a_balance = 1000;

-- 0. 开启事务 
START TRANSACTION;
-- 转账操作
UPDATE account SET a_balance = a_balance - 500 WHERE a_name = 'tom';
-- 加入异常
。。。
UPDATE account SET a_balance = a_balance + 500 WHERE a_name = 'jerry'; -- failed

-- 出现问题 tom 500 jerry 1000回滚事务
-- 将状态恢复到start transaction 之前
ROLLBACK;

-- 如果没有问题 提交 
COMMIT;


  ```

3. mysql数据库默认自动提交 (oracle默认手动提交)
   - 一条DML(增删改)语句会自动提交一次事务 -- 即数据持久化更新 
   - 修改事务的默认提交方式 
     - *select @@autocommit* 1代表自动提交开启
     - set autocommit = 0
     - 这样一来执行DML语句之后不commit，语句是不会生效的

​     

4. 事务四大特征
   1. 原子性：是不可分割的最小单位，要么同时成功，要么同时失败
   2. 持久性：当事务回滚或者提交后，数据库会持久化的保存数据
   3. 隔离性：多个事务间相互独立
   4. 一致性：事务操作前后，数据总量不变

5. 事务的隔离级别
   1. 概念：多个事务之间相互独立，但是当不同的事务操作同一块数据时会引发问题，这时设置不同的隔离级别就可以解决这些问题
   2. 问题
      1. 脏读：一个事务读取到另一个事务没有提交的数据
      2. 不可重复读(虚读)：同一个事务中，，两次读取的数据不一样
      3. 幻读：第一个事务操作修改了表中的所有记录，第二个事务添加了一条记录，则第一个事务查询不到自己的修改
   3. 隔离级别
      1. read uncommitted
         - 产生问题  脏读，不可重复读，幻读
      2. read commited（oracle默认）
         - 不可重复读，幻读
      3. repeatable read（mysql默认）
         - 幻读
      4. serializable: 串行化
         - 解决所有问题
      5. 隔离级别从小到大，安全性越来越高，效率越来越低
   4. 设置隔离级别
      - 。。。



## DCL_用户管理





# MYBATIS

> 笔记在[语雀](https://www.yuque.com/kangyin-2fcso/twkvol/wkr7hg)上
>
> 项目本地路径 javaee-workspace/learn-mybatis



---

