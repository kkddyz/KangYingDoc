# 	JDBC

- 概念：Java DataBase  Connectivity(java数据库连接)，即使用java语言操作数据库。

- 本质：java官方规定了一套适用所有关系型数据库的规则(接口)。由各个数据库软件去实现这套接口，他们提供所谓的**数据库驱动jar包**(封装好了实现类)。java程序员通过==接口编程(JDBC)==间接使用驱动，真正执行的代码在驱动jar包里。

  图解：
  
  ![img](https://i.loli.net/2020/04/19/hsAiepJfTLPKycQ.png)

本质上就是针对接口编程

![image-20210917193036829](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210917193036.png)

> 项目位置 ： `F:\javaSE_workspace\src\jdbc学习\jdbc_maven` 

---



## 基本使用

### 使用流程

1. 通过参数url,username.pwd建立连接
2. 使用statement执行语句
3. 封装结果集(查询)

![image-20220503150549888](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220503150550.png)

### JDBCUtils

通过封装创建conn，释放资源这部分代码，简化使用。

这样通过Util实现对conn对象的管理



#### 读取配置文件

将连接数据库的必要信息，写入prop配置文件，通过FileIPS流load到内存。

由于文件只需要读取一次，因此在static块中读取配置。

```JAVA
// 读取配置
static {
    // 加载文件
    Properties prop = new Properties();
    InputStream fileIps = null;
    try {
        // 使用类加载器查找文件
        fileIps = JDBCUtils.class.getClassLoader().getResourceAsStream("jdbc.properties");
        prop.load(fileIps);

        // 读取配置
        user = prop.getProperty("user");
        password = prop.getProperty("password");
        url = prop.getProperty("url");

    } catch (FileNotFoundException e) {
        System.out.println("请检查配置文件路径");
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            if (fileIps != null) {
                fileIps.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

> 使用类加载器只能获取src下，即JVM编译后的class目录下的文件。
>
> 且要在src一级目录下，如果在二级目录需要写路径 具体参考[文章](https://hacther.cn/124.html)
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220503173634.png" alt="image-20220503173634302" style="zoom:80%;" align="left"/>



#### 实现get与close

````JAVA
    public static Connection getConn() throws SQLException {
        return DriverManager.getConnection(url, user, password);
    }

    public static void close(Connection connection, Statement statement) {

        try {
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }
        } catch (SQLException exception) {
            exception.printStackTrace();
        }
    }
````



### 类详解

#### DriverManager 

![image-20220503151604113](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220503151604.png)

#### Connection

![image-20220503151750445](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220503151750.png)

#### Statement 

用于执行静态sql语句，并返回生成结果。

![image-20220503164837746](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220503164837.png)

#####  DML 增删改 + DDL 修改表

下面模拟实现excuteUpdate

```java
public static void executeUpdate(String sql) {

    Connection conn = null;
    Statement stmt = null;

    String url = "jdbc:mysql://localhost:3306/test";
    String user = "root";
    String pwd = "123456";

    try {
        // 创建conn
        conn = DriverManager.getConnection(url, user, pwd);
        // 创建stmt
        stmt = conn.createStatement();
        // 执行SQL语句
        int cnt = stmt.executeUpdate(sql);
        // cnt：影响行数
        if (cnt > 0) {
            System.out.println("executeUpdate成功");
        } else {
            System.out.println("executeUpdate失败");
        }
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        // 释放资源
        try {
            // 防止NPE
            if (stmt != null) {
                stmt.close();
            }
            if (null != conn) {
                conn.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

> 注意需要使用try-catch-finally，确保资源被释放。
>
> ---
>
> executeUpdate还可以去修改表



##### DQL 

```JAVA
String url = "jdbc:mysql://localhost:3306/learn_sql";
String querySql = "select bookid, bookname, price from t_book order by bookid";

Connection conn = null;
Statement stmt = null;
ResultSet resultSet = null;

try {
    conn = DriverManager.getConnection(url, "root", "123456");
    stmt = conn.createStatement();
    resultSet = stmt.executeQuery(querySql);

    // 遍历resultSet
    while (resultSet.next()) {
        System.out.print(resultSet.getURL(1) + "\t");
        System.out.print(resultSet.getString(2) + "\t");
        System.out.println(resultSet.getInt("price"));
    }
} catch (SQLException e) {
    e.printStackTrace();
} finally {
    try {
        if (resultSet != null) {
            resultSet.close();
        }
        if (stmt != null) {
            stmt.close();
        }
        if (conn != null) {
            conn.close();
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
```



#### ResultSet

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220503164615.png" alt="image-20220503164614962" style="zoom:100%;" align="left"/>

- result的遍历类似于迭代器，通过`next()`判断是否有下一个属性,,并移动到下一列。



> 关系型数据库中每一行是一条记录，RS容器中的对象就是"记录"。
>
> 每一条记录有多"列"，每一列就是一个属性，属性由索引，属性名，属性值构成。
>
> 属性值的类型是Obj,getXXX会将Obj转型，getXXX通过索引或者名称定位属性。

```JAVA
// bookid的类型为int 
String querySql = "select bookid, bookname, price from t_book order by bookid";
resultSet = stmt.executeQuery(querySql);

// 遍历resultSet
while (resultSet.next()) {
    // 获取idx=1的属性,转型iInt
    System.out.print(resultSet.getInt(1) + "\t");
    // 获取idx=2的属性,转型为String
    System.out.print(resultSet.getString(2) + "\t");
    // 获取name="price"的属性,转型为int
    System.out.println(resultSet.getInt("price"));
}
```

> - 获取到的属性值，都是字符串，然后解析为不同的数据类型
> - getInt --> int str = getString(arg); return Integer.paseInt(str);
> - 所有字段都可以使用getString()获取原始字符串

---

上面实现了遍历，下面就Emp为例，通过遍历RS，实现结果集的手动封装。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220503165255.png" alt="image-20220503165255829" style="zoom:80%;" align="left"/>



#### PreparedStatement

![image-20220503174702068](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220503174702.png)

```JAVA
// 创建PreparedStatement
String sql = "insert into t_book(bookid,bookname,price) values(?,?,?)";
PreparedStatement pstmt = conn.prepareStatement(sql);

// 填充占位符
pstmt.setInt(1, 10);
pstmt.setString(2, "Effective Java";);
pstmt.setInt(3, 50);

// 执行
pstmt.executeUpdate()
```

> PreparedStatement是如何防止SQL注入的？
>
> 在填充占位符时，会将
>
> <u>整个参数用引号包起来，并把参数中的引号转义，从而避免了参数也作为条件的一部分</u>

### 事务管理

![image-20220503193012691](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220503193013.png)

​	

mysql默认开启自动提交，因此没有设置`conn.setAutoCommit(false)`前是不存在事物的。

当前事务从`conn.setAutoCommit(false)`开始，到`conn.commit()`结束。

```JAVA
try(){
    conn = getConn();
    // 开启事务
    conn.setAutoCommit(false);
   
    // 执行DML操作
    doUpdate();
    
    // 提交事务
    conn.commit();
}catch(Exception e){
    // 出现异常，回滚事务
    conn.rollbacke();
}finally{
	conn.close();
}
```

回滚是回到上一个保存点，如果没有设置，就会撤销事务中的所有操作。



#### 保存点

**有的时候可能并不需要将一整个事务进行回滚，一个复杂的事务可能由几个一致性的阶段组成**

**保存点就是在一个事务中，插入几个还原点，再出现问题时，可以及时的撤回到这个地方来**。

**当撤回到一个还原点时，事务仍在进行中，需要COMMIT，rollback终止**



```JAVA
Connection conn = DriverManager.getConnection(url, user, password);
Statement stmt = conn.createStatement();
String sql1 = "delete from student where id='158'";
String sql2 = "delete from student where id='159'";

try{
    // 开启事务
    conn.setAutoCommit(false);
    
	stmt.executeUpdate(sql1);
	Savepoint savepoint1 = conn.setSavepoint("savepoint1"); // 保存点1

	stmt.executeUpdate(sql2);
	Savepoint savepoint2 = conn.setSavepoint("savepoint2"); // 保存点2
    
    // 结束事务
    conn.commit();
}catch(Exception1 e){
    // 回到保存点1
    conn.rollback(savepoint1);
    // 尝试处理异常1
    if(handleException(e) == true){
		conn.commit()
    }else{
        conn.rollback();
    }
}catch(Exception2 e){
    conn.rollback();
}finally{
    conn.close();
	stmt.close();
}
```

> 发生异常1时，保存点1之前的操作没有问题，保存点1的操作之后回滚。
>
> 尝试处理异常1（重新执行保存点1之后的代码）
>
> - 如果处理成功commit()
> - 如果失败，只能回滚。
>
> 发生异常2，说明在保存点1之前的操作就已经失败，直接回滚。

所以，不论回到哪一个存档的，最终要么通过commit提交事务，要么通过rollback回滚事务。

---



## 数据库连接池

>  对coon对象进行管理 + 复用
>
>  项目路径 javase-workspace/jdbc学习 

### 为什么需要连接池？？

首先，看一段jdbc的代码

```
  public static void main(String[] args) throws Exception {

        // 创建连接对象
        String url = "jdbc:mysql://localhost:3306/learn_sql" ;
        String user = "root";
        String password = "123456";
        Connection connection = DriverManager.getConnection(url,user,password);

		// 执行sql语句..... 

		// 销毁连接对象
		connection.close();
```

我们每次都要获取连接对象，才能执行sql语句，执行完了就销毁。

如果sql操作很频繁，这样做是很浪费资源的。

正确的做法是将所有的connection对象放在一个容器中，轮流为sql语句提供服务。

这就是我们学习的连接池的概念。

### 连接池概念

当系统初始化后，容器被创建，容器会申请一些conn对象，当用户需要访问数据库时，从容器中获取conn对象，操作结束后将coon对象归还给容器。

![数据库连接池, websocket - 二号- 博客园](https://images2018.cnblogs.com/blog/1341090/201809/1341090-20180907154623461-1688490853.png)

### DataSource对象

我们从那里获取coon对象呢？？

当当当，那就是DataSource接口。

注意哦，这个接口的实现类由数据库厂商提供驱动实现。

```java
Connection conn = dataSource.getConnection();
```

我们只需要上面这行代码就可以获取到conn对象哦.、

下面有两个常用的连接池

Druid ： alibaba提供的连接池技术 （全世界最好的数据库连接池技术哦）

C3P0 : ( 这个没学诶)

### Duird连接池

#### pom.xml

```hxml
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>druid</artifactId>
	<version>1.1.16</version>
</dependency>
```



#### 配置文件：druid.prop

```properties
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://127.0.0.1:3306/db_name
username=root
password=123456
initialSize=5
maxActive=10
maxWait=3000

filters=stat
timeBetweenEvictionRunsMillis=60000
minEvictableIdleTimeMillis=300000
validationQuery=SELECT 1
testWhileIdle=true
testOnBorrow=false
testOnReturn=false
poolPreparedStatements=false
maxPoolPreparedStatementPerConnectionSize=200
```



#### 使用模板

```java
public class DruidDemo {
    public static void main(String[] args) throws Exception {

		// 创建prop对象,导入配置
        Properties prop = new Properties(); 
        // druid.properties --> in --> prop对象
        // "/druid.properties" 表示从类路径开始寻找
        InputStream in = DruidDemo.class.getResourceAsStream("/druid.properties");	
        prop.load(in); 

		// 使用静态工厂创建连接池
        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);

        // 获取连接
        Connection conn = dataSource.getConnection();

		// 归还连接
		conn.close();
		// 连接池提供的conn对象的close()封装了归还对象到连接池的操作，用户不用关心
    }
}
```

#### 模拟实现工厂方法

> 工具类中通过静态代码块，读配置创建连接池。
>
> 封装了使用方法: getDatabase(),getConn(),close();

```JAVA
/* 
	使用静态成员，静态代码块，实现单例模式
	这个Demo提供了”如何使用工具类实现单例模式“ 的方法
*/

public class JDBCUtils {
    private static DataSource ds;

    // 创建静态成员 ds
    static {
        Properties prop = new Properties();
        InputStream in = DruidDemo.class.getResourceAsStream("/druid.properties");
        try {
            prop.load(in);
            ds = DruidDataSourceFactory.createDataSource(prop);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 获取连接
     */
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }

    /**
     * 释放资源
     */
    public static void close(Statement stmt,Connection coon){
        if (stmt!=null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if (coon!=null){
            try {
                coon.close(); // 归还连接
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    public static void close(ResultSet rs,Statement stmt, Connection coon){
        if (rs!=null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        close(stmt, coon);
    }


    public static DataSource getDaSource(){
        return ds;
    }
}
```

---

### C3P0连接池

#### pom.xml

```
<dependency>
	<groupId>c3p0</groupId>
	<artifactId>c3p0</artifactId>
	<version>0.9.1.2</version>
</dependency>
```

#### 配置文件

- 一般使用c3p0-config.xml配置,也可是c3p0.properties

```XML
<?xml version="1.0" encoding="UTF-8"?>
<c3p0-config>
	<default-config>
		<property name="driverClass">com.mysql.cj.jdbc.Driver</property>
		<property name="jdbcUrl">jdbc:mysql://localhost:3306/learn_c3p0</property>
		<property name="user">root</property>
		<property name="password">123456</property>
		<property name="acquireIncrement">5</property>
		<property name="initialPoolSize">10</property>
		<property name="minPoolSize">5</property>
		<property name="maxPoolSize">20</property>
	</default-config>
	


```

#### 建表

```SQL
CREATE DATABASE learn_c3p0;
USE learn_c3p0;

CREATE TABLE account(
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(40),
	money FLOAT
)CHARACTER SET utf8 COLLATE utf8_general_ci;

INSERT INTO account(NAME,money) VALUES('account1',1000);
INSERT INTO account(NAME,money) VALUES('account2',800);
INSERT INTO account(NAME,money) VALUES('account3',1200);
```

#### 模板

```JAVA
public class C3P0Demo {
    public static void main(String[] args) throws SQLException {

        // 1. 创建数据库连接对象
        DataSource ds = new ComboPooledDataSource();

        // 2. 获取连接对象
        Connection conn = ds.getConnection();

        // 3. print
        System.out.println(connection);
        
        // 4. 归还对象
        conn.close();
    }
}

```

> 与druid不同，不用我们自己导入配置.
>
> ComboPooledDataSource在创建时会去寻找`c3p0-config.xml`，也就是说这个文件的名称是不可以修改的。





---

## dbutils

dbutils是对jdbc的封装与jdbcTemplate类似。

> 项目路径 javase-workspace\jdbc学习\dbutils



![image-20210918203614619](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210918203614.png)

### 自定义实现DML



dbassist.java

```JAVA
 public int update(String sql, Object... params) {
        Connection conn = null;
        PreparedStatement psmt = null;

        try {
            // 1. 获取连接
            conn = dataSource.getConnection();
            // 2. 创建PreparedStatement对象
            psmt = conn.prepareStatement(sql);
            // 3. 得到sql语句的元信息(有几个参数,什么类型),判断params与?数量是否一致
            ParameterMetaData parameterMetaData = psmt.getParameterMetaData();
            int parameterCount = parameterMetaData.getParameterCount();
            if (params == null){
                throw new NullPointerException("参数为空");
            }
            if (params.length != parameterCount){
                throw new RuntimeException("希望"+parameterCount+"个参数,但是传入的参数只		``					有"+params.length+"个");
            }
            // 4. 给sql赋值

            for (int i = 0; i < parameterCount; i++) {
                // 通过index确定obj从1开始,数组从0开始
                psmt.setObject(i+1,params[i]);
            }
            // 5. 执行语句
            int res = psmt.executeUpdate();
            // 6. 返回结果
            return res;

        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }finally {
            release(conn,psmt,null);
        }
        return 0;
    }
```

> mysql默认开启自动提交，mybatis session不开启。
>
> 连接池只管理conn。

### 自定义实现DQL

之前的操作到执行语句位置都是一样的,不一样的就是需要封装结果集.

```JAVA
return rsh.handle(rs);
```

BeanHandler

```java
 public T handle(ResultSet rs) {

// 1. 创建实体类对象
T bean = domainClass.newInstance();

// 2. 判断结果集是否为空 rs.next()取出rs集合中的一个对象，如果没有返回null
if (rs.next()) {

	// 3. 根据元信息
	ResultSetMetaData rsMetaData = rs.getMetaData();
	// 循环抽取每一列数据 : 首先获取Bean对象的writeMethod,然后将属性值写入
	for (int i = 0; i < rsMetaData.getColumnCount(); i++) {
		
		//获取每列的name 
		String columnName = rsMetaData.getColumnName(i + 1); // 列从1开始数
		columnName = columnName.toLowerCase(); // 转换为小写
		
		// 获取属性值
		Object propertyValue = rs.getObject(columnName);
		
		// 获取writeMethod() :  需要借助于属性描述器
		PropertyDescriptor pd = new PropertyDescriptor(columnName,domainClass);
		Method writeMethod = pd.getWriteMethod(); // 获取写入数据的方法
		
		// 给对象赋值
		writeMethod.invoke(bean,propertyValue);
	}
}

//4. 返回对象
return bean;


}
```

> 需要注意的是将表格的列名转换为小写,保证列名与属性名一致



> 查询所有dao的实现只需要改变封装结果集的策略;
>
> 即创建一个BeanListHandler实现ResultSetHandler接口

```java
@Override
public List<T> handle(ResultSet rs) {

    List<T> beans = new ArrayList<>();

    try {
        while (rs.next()) {
            // 1. 创建实体类对象
            T bean = domainClass.newInstance();
            ResultSetMetaData rsMetaData = rs.getMetaData();

            // 2. 将rs数据封装到bean中
            for (int i = 0; i < rsMetaData.getColumnCount(); i++) {
                
                String columnName = rsMetaData.getColumnName(i + 1);
                columnName = columnName.toLowerCase();
                PropertyDescriptor pd = new PropertyDescriptor(columnName, domainClass);
                Method writeMethod = pd.getWriteMethod();
                Object propertyValue = rs.getObject(columnName);
                writeMethod.invoke(bean, propertyValue);
            }

            // bean加入集合
            beans.add(bean);
        }
        return beans;


    } catch (SQLException | IntrospectionException | InvocationTargetException | InstantiationException | IllegalAccessException throwables) {
        throwables.printStackTrace();
    }

    return null;
}
```

---

### QueryRunner

- 相当于JDBCTemplate 
- 相当于自定义的DBAssist

如果使用不提供DataSource创建的QueryRunner对象在执行方法是需要提供Conn对象.

如果通过使用连接池就不需要提供Coon对象了.

query()也同样需要一个ResultSetHandler接口的实现类

dbutils包提供了我们之前实现的BeanHandler和BeanListHandler实现类



> 传入datasource,那么每次语句的执行都是独立的事务.
>
> dao每一次调用函数,都会从连接池获取到一个conn,然后执行语句.
>
> 这样每个dao函数之间是独立的,不能实现转账这样需要多条sql,多个dao操作 的 情景.
>
> 所以dbutil提供带conn的方法,这样只要所有操作都使用同一个conn就能保证同步性. 

#### 基本使用

##### maven依赖

```XML
 <dependency>
            <groupId>commons-dbutils</groupId>
            <artifactId>commons-dbutils</artifactId>
            <version>1.7</version>
        </dependency>
```

##### 实现dao

```JAVA
/**
 * @author kkddyz
 *
 * 使用dbutils实现dao
 */
public class AccountDaoImpl implements IAccountDao {


    private QueryRunner queryRunner = new QueryRunner(C3P0Utils.getDataSource());

    @Override
    public void saveAccount(Account account) {
        String saveAccountSql = "insert into account(name,money) values(?,?)";
        String name = account.getName();
        Float money = account.getMoney();
        try {
            queryRunner.update(saveAccountSql, name, money);
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }

    @Override
    public Account findAccountById(Integer id) {

        String sql = "select * from account where id = ?";

        try {
            return queryRunner.query(sql,new BeanHandler<>(Account.class),id);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

    }

    @Override
    public List<Account> findAll() {
        String sql = " select * from account";

        try {
            return queryRunner.query(sql,new BeanListHandler<>(Account.class));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```

> 我很好奇 query是如何判断应该返回T 还是List<T> 它的接口是如何定义的.



## JDBCTemplate

> 1. 实现对CRUD操作的简单封装
> 2. 提供简单的结果集封装
>



### 出现原因

我们在获取conn对象后，还需要获取statement对象，执行后还需要手动将结果集封装到实体类中很麻烦，能不能将这些操作简化呢？？

基于这些需求,Spring的JDBCTemplate 提供的对JDBC的简单封装。

### 创建Tamplate

- 这个对象依赖DataSource对象 -- 通过连接池提供

```java
//配置 数据库连接池
JdbcTemplate template = null;
try {
    // JDBCUtils封装创建数据库连接池的过程
    template = new JdbcTemplate(JDBCUtils.getDaSource());
} catch (Exception e) {
    e.printStackTrace();
}
```

### DML操作

update() 操作

```JAVA
public class TemplateDemo1 {
    public static void main(String[] args) {
        // 1. 需要配置 数据库连接
        JdbcTemplate template = null;
        try {
            template = new JdbcTemplate(JDBCUtils.getDaSource());
        } catch (Exception e) {
            e.printStackTrace();
        }

        // 2. 调用方法 templateJDBC内部封装了PreparedStatement
        String update_sql = "update test1 set age = ? where id = ?";
        int test1 = template.update(update_sql,30,1);
        System.out.println(test1); // 返回1 success

        String insert_sql = "insert into test1 (id,age) values (?,?);";
        int test2 = template.update(insert_sql, 4, 18);// 参数化sql查询
        System.out.println(test2);
    }
}
```

> 类似的还有insert(),delete()都属于DML,不赘述了。

### :star: DQL

#### queryForMap

queryForMap() ： 将一条记录封装为Map<String,Object>

```JAVA
@Test
public void testQueryForMap() {
    int id = 1;
    String sql = "select * from test1 where id = ?";
    Map<String, Object> stringObjectMap = template.queryForMap(sql, id);
    System.out.println(stringObjectMap);
}
```

**<font color="red">注意查询到的记录数量只能为1(不然会报错)；</font>**

---

#### queryForList

queryForList() ： 将Map对象装入List容器，用于封装多条记录

```JAVA
  	//我们通过queryForList来实现多条记录的查询
  	@Test
    public void testQueryForList() {
        int age = 20;
        String sql = "select * from test1 where age = ?";
        List<Map<String, Object>> maps = template.queryForList(sql, age);
        for (Map<String, Object> map : maps) {
            System.out.println(map);
        }
    }
```



上面两个都只是将结果集中的数据装入Object对象，而下面会将Obj的数据写入Person对象。

> 插一嘴，一开始有个很好笑的念头就是为啥不可以直接将Object对象强转为Person对象；
>
> 原因是，这种想法的前提是，数据库表中的列名和java对象的属性必须完全一样。
>
> 但这是一种尽量应该实现的规范，但是有时无法实现，且也没有办法保证。
>
> 所以，需要通过反射的方式，根据Mapper策略封装属性



#### query() 

> 通过RowMapper接口定义封装结果集的实现

##### 手撸RowMapper

```JAVA
public void testQuery() {

    /*
  		query()循环调用RowMapper.mapRow()
 		每次传入一个rs对象，返回一个javaBean对象
  		
    */
    
    // 手写RowMapper接口实现方法
    List<People> peopleList1 = template.query(sql, new RowMapper<People>() {
        @Override
        public People mapRow(ResultSet resultSet, int i) throws SQLException {
            // 创建对象
            People people = new People();
            // 数据 : rs -> java bean 
            people.setId(rs.getInt(1));
            people.setAge(rs.getInt(2));
            // 返回对象到容器
            return people;
        }
    });

```

> 这样写好麻烦, 我们发现只要让table的列与javaBean属性一致就可以通过反射自动实现。
> 那么有没有这样的RowMapper实现类给我们使用呢？？
> 有的 BeanPropertyRowMapper对象通过.class,就可以自动创建对象+抽取rs列到bean中

---

##### BeanPropertyRowMapper

- 自动实现封装
- 前提：保证bean属性与table col一致。

```JAVA
//泛型，字解码，写一个就行
List<People> peopleList2 = template.query(sql, new BeanPropertyRowMapper<>(People.class)); 
```

> 注意 ： bean成员不能是基本类型
>
> BeanPropertyRowMapper 对于table中的空值(查询表中得到空值)会装入null,但是基本类型不能接受null，所以Bean类的成员属性必须是对象（包装）。



<font color="blue">此外，queryForObject() : 返回单个对象。</font>



---

### JdbcDaoSupprot(还没看，spring部分的)

在Ioc配置时，存在重复的代码

```
pricate JbdcTemplate template;

public void setTemplate(JbdcTemplate template){
	this.template = template;
}
```



定义一个父类 JdbcDaoSupport定义注入template的函数

```JAVA
/**
 * @author kkddyz
 *
 * 用于抽取dao中重复的部分: 注入template
 *
 * 通过继承使用这部分代码
 */
public class JdbcDaoSupport {

    /**
     * 直接注入Template
     */
    private JdbcTemplate template;

    public void setTemplate(JdbcTemplate template) {
        this.template = template;
    }

    public JdbcTemplate getTemplate() {
        return template;
    }

    /**
     * 通过datasource创建template
     */
    private DataSource dataSource ;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;

        if (template == null){
            template = createTemplate(dataSource); 
        }

    }

    private JdbcTemplate createTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }


}
```



在使用dao时只需要继承该类，然后再配置中注入template或者datasoure依赖即可

（通过继承得到setDatasource() ）

---

spring中定义好了这个类，当然由于这个类在jar包中无法使用注解实现配置

# Mysql

## MYSQL服务器

#### 软件安装 

通过Installer安装  [默认安装教程教程](https://zhuanlan.zhihu.com/p/37152572)

##### 选自定义安装

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210708135011.png" alt="image-20210708135011351" style="zoom:33%;" align="left" />

> 因为默认安装的目录找起来很麻烦；所以需要[自定义安装目录](https://blog.csdn.net/qq_38978315/article/details/104489099)；
>
> 后面和[默认安装](https://zhuanlan.zhihu.com/p/37152572)一样
>
> 1. 安装目录：D:\MySQL\MySQL_Server (不要有空格最好)
>
> 2. 数据目录 ：D:\MySQL\MySQL_Server_Data
>
> 3. 基本信息都能在配置文件my.ini中找到



##### 管理

通过installer程序管理(就放在D盘mysql目录下)

##### 彻底卸载

安装失败，把installer删除后按下面的来

https://www.jianshu.com/p/491f837e434b

#### 打开与关闭服务

1. 启动服务

   `管理员权限：net start mysql80` [^ 1]

2. 关闭服务

   `管理员权限：net stop mysql`80

3. 打开"服务" 手动设定

#### 登录域退出服务

1. 登陆：cmd输入“`mysql -uroot -p`”回车，然后输入设置的root账号的密码`123456`

2. 退出 `exit/quit`

#### 远程登录

- 连接其他主机的mysql服务

  `mysql -h127.0.0.1 -uroot -p` 

---

[^1]: mysql80是安装的时候你起的mysql服务名



mysql安装

#### 查看信息

- 版本

- 直接在操作系统命令行下执行：`MySQL –V` 8.0.19

- 时区

  - ```
    show variables like "%time_zone%";
    ```

<img src="https://i.loli.net/2020/04/18/vOmyhaEuKZ56P8D.png" style="zoom:50%;" align="left" />

- show variables like '%dir%';

  查看基本信息





### 时区问题

1.  [设置时区](https://www.jianshu.com/p/f190650a6c7f)

GMT（Greenwich Mean Time）：格林威治标准时间
UTC：世界标准时间
CST（China Standard Time）：中国标准时间

GMT + 8 = UTC + 8 = CST

#### 报错

##### 1. IDEA 连接报错

<p style="color : red;">Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezone’ property manually.</p>

##### 2.jdbc连接mysql出错

`java.sql.SQLException: The server time zone value ‘XXXXXX’ is unrecognized or represents more than one time zone.`
`You must configure either the server or JDBC driver (via the serverTimezone configuration property)` 
`to use a more specifc time zone value if you want to utilize time zone support.`

#### 原因：

硬件服务器(操作系统)时间和软件服务器时间(mysql服务器时间软件)不一样。

MySQL默认的时区是*UTC(世界标准时间)时区*，比北京时间(系统时区CST)晚8个小时。

#### 解决办法 

修改服务器软件时区设置(硬件时区改不了)

由于 CST = UTC + 8；

- `set global time_zone='+8:00';` // 

- 修改my.ini

  ```mysql
  [mysqld]
  default-time-zone = '+08:00'
  ```

<font color="red">必须重启服务才能更新my.ini的配置，不是重新启动cmd! ! ! ! !</font>

---



#### [安装](https://zhuanlan.zhihu.com/p/82899047) installer程序

#### 删除

卸载也是在installer里进行。别看网上那些杂七杂八的东西。

#### 数据库信息

名称：MySQL80

[修改数据库字符集](https://my.oschina.net/wangt10/blog/508374)

utf8mb4是utf8的超集

---





---

---



## SQL基础

- structure query language 结构化查询语言
- 定义了操作所有**关系型数据库**的规范。但是每种数据库的操作方式与规范存在不一样的地方称为“**方言**”。 



### SQL通用语法

- 注释
  - 单行：# 或者 -- （两个短横杠+空格）
    -  -- 注释；是一种通用注释 #是sql特有的
  - 多行：/* */

### SQL分类

1. DDL (data definition language) 定义模板

   - 用来定义数据库对象：数据库，表，列；

2. DML(manipulation)  操作模板对象

   - 操作数据库的表中数据

3. DQL (query) 查询

   - 查询操作数据库的表中数据
   
4. DCL (control) 控制

   - 设置数据库的访问权限



### SQL的数据类型

- 整数类型 ：age int

- 浮点类型：grade double(5,2) # **数共5位，小数点后2位**

- 日期类型：

  - date yyyy--MM--dd #日期 年月日
  - datetime yyyy--MM--dd HH:mm:ss #时间 年月日 时分秒 
  - timestamp 格式同datetime # 时间戳 : 默认值(不赋值 || 赋值为null) 当前的系统时间

    -  value = CURRENT_TIMESTAMP;

- 字符串类型:

  - varchar(10)  

    #可变字符串 不超过10个字符(汉字和字母都占一个字符utf8编码)

  - character(10) (character就是char缩写  )# 字符串**固定长度**10
  
- txt # 0-65535字节(单位不是字符)，用于存储大型文本 

### 数据库DDL：CRUD

#### C(create )

- 创建不存在的数据库：
  - create database **if not exists** learn_sql;
  - 默认字符集是utf-8
- 指定字符集字符集
  - create database learn_sql **character set gbk**;

#### R(retreieve)

- 查询所有数据库名称
  
  - `show databases`;
  
- 查询mysql默认的的字符集
  
  - `show variables like 'character%'`;
  
- 查询某个数据库的创建语句(常常用来看数据库)

```shell
show create database mysql;

CREATE DATABASE `mysql` 
/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */
```

#### U(update)

- 修改数据库的字符集
  - **alter** database <database_name>  character set gbk;

#### D(delete)

- **drop** database if exists <database_name>

#### 使用数据库

- 使用数据库 (相当于进入文件夹)
  - use <database_name>
- 查询正在使用的数据库
  - select database();

### 表DDL ：CRUD

#### C (Create 创建)

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200712121906.png" alt="image-20200712121906756" style="zoom:80%;" align="left"/>

---

#### R (Retrieve 查询)

- 查询数据库的所有表 
  - show tables;
- 查询表的属性
  - show create table <table_name>;
- 查询表**结构**<font color="blue"> 不是内容对象 而是表这个类</font>
  - desc <table_name> # describe 描述这个表
  ![image-20200712115511507](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200712115511.png)

---

---

#### U(Update 修改)

1. 修改表的属性

   - alter table <table_name> rename to <new__name>; 

     #操作类型(alter)+对象(table student) + 具体操作(rename to) + 操作参数 

   - alter table <table_name> character set utf8;

2. 修改表的结构(列属性)

   ![image-20200712123655390](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200712123655.png)


#### D(Delete 删除) 

删除表`drop table if exists <table_name>;`



### DML

```mysql
# 创建表 时间戳得设默认值DEFAULT CURRENT_TIMESTAMP 不然没用 
CREATE TABLE student(
	id INT,
	NAME VARCHAR(32),
	age INT,
	score DOUBLE(4,1),
	birthdat DATE,
	insert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP

);
DESC student; 
#DML data manipulation language 操作模板数据


# 添加数据 
INSERT INTO student(id,NAME,age) VALUES(1,"张三",18);
SELECT * FROM student;

# 省略列名 默认values匹配所有列 传入null，数据库就会使用默认值即CURRENT_TIMESTAMP
INSERT INTO student VALUES(2,"李四",18,99.9,"2020-12-12",null);


# 删除，修改数据都得先找到数据，在sql里使用where设置查找条件

# 删除数据 
DELETE FROM student WHERE id=1; 
SELECT * FROM student;

#如果不加条件 默认删除所有记录 这是因为where语句会逐一检查所有条件对符合条件的记录执行操作
#这样效率很低 
#执行truncte语句代替 -- 直接删除表，然后创建一样的空表,以此达到清空的效果；
TRUNCATE TABLE student;

#修改数据,可以同时修改记录的多个属性
UPDATE student SET age=118,sore = 100 WHERE id=1;
#and连接where条件(OR)
UPDATE student SET age=117 WHERE id=2 AND birthday="2020-12-12";
```

---

### DQL

#### 语法

```mysql
select 

​	[...字段]

from

​	[...表名]	

where

​	[...条件]

group by

​	[...分组字段]

having

​	[分组之后的条件]

order by

​	[...排序字段]

limit

​	分页限定
```

#### 基础查询

```sql
# 创建成绩表
CREATE TABLE student_score(   
	id INT,  -- 编号   
	NAME VARCHAR(20), -- 姓名   
	age INT, -- 年龄   
	sex VARCHAR(5),  -- 性别   
	address VARCHAR(100),  -- 地址   
	math INT, -- 数学   
	english INT -- 英语 
); 
# 添加数据
INSERT INTO student_score(id,NAME,age,sex,address,math,english) 
VALUES  
	(1,'马云',55,'男', ' 杭州',66,78),
	(2,'马化腾',45,'女','深圳',98,87),
	(3,'马景涛',55,'男','香港',56,77),
	(4,'柳岩 ',20,'女','湖南',76,65),	
	(5,'柳青',20,'男','湖南',86,NULL),
	(6,'刘德华',57,'男','香港 ',99,99),
	(7,'马德',22,'女','香港',99,99),
	(8,'德玛西亚',18,'男','南京',56,65); 
# 最基本的一句查询
SELECT * FROM student_score;

# 查询部分列
SELECT address FROM student_score;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200713200625.png" alt="image-20200713200623957" style="zoom: 80%;" align="left"/>

##### 去重

<font color="blue">我们只想知道这些人来自哪些城市，因此重复出现的城市很碍眼 -- 需要<font color="red">去重</font>。</font>

```mysql
#去除重复的结果集
SELECT DISTINCT address FROM student_score;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504115202.png" alt="image-20220504115202665" style="zoom:80%;" align="left"/>

> distinct用于去重复的结果集 -- 将查询到的部分(列)，去重
>
> `SELECT DISTINCT address,name FROM student_score;`
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504115049.png" alt="image-20220504115049137" style="zoom:80%;" align="left"/>
>
> ---
>
> 这个操作一般用于统计不重复记录的数量
>
> `SELECT COUNT(DISTINCT address,NAME) AS "不重复记录数量" FROM student_score;`
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504114231.png" alt="image-20220504114231515" style="zoom:80%;" align="left"/>
>
> 因为，只能显示不重复的部分，如果想要显示所有信息可以使用`group by`.



##### 计算列

<font color="blue">假设我想知道他们的总分，但是没有这列有什么办法呢？？</font>

<font color="red">sql允许数据(int,double,null)计算</font>

```mysql
SELECT NAME,math,english,math+english FROM student_score;# 计算 
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200713201858.png" alt="image-20200713201858477" style="zoom:80%;" align="left"/>

##### null运算

<font color="blue">有null参与的sql运算结果为null(显然不合理)。</font>

<font color="blue">其实null参与运算本身就不合理因此结果为null意思是没有结果；</font>

<font color="blue">如何解决(遇到null特殊处理).</font>

在sql有专门一个ifnull函数用于替换运算中的null值;

```mysql
# 特殊处理NULL 
SELECT NAME,math,english,math+ifnull(english,0) FROM student_score;
# 相当于单目运算符 优先级在+之上,运算时先判断变量english是否为null，ifnull成立对变量赋值，这里是0
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200713202526.png" alt="image-20200713202525979" style="zoom:80%;" align="left"/>

---

##### 起别名

<font color="blue">虽然实现了运算，但是运动结果好长也不便于理解。</font>

```mysql
# 起别名
SELECT NAME,math,IFNULL(english,0) AS english,math+IFNULL(english,0) AS SUM FROM student_score;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504120001.png" alt="image-20220504120000978" style="zoom:80%;" align="left"/>

起别名时可以加"",外部语句使用时不要使用""不然会被当成字符串。

![image-20220504195034623](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504195034.png)

```MYSQL
SELECT 
	员工编号,员工姓名,工资,职务名称,职务描述,dname AS "部门名称",loc AS "部门位置"
FROM 
	(SELECT 
		emp.`id` AS "员工编号",
		emp.`ename` AS "员工姓名",
		emp.`salary` AS "工资",
		job.`jname` AS "职务名称",
		job.`description` AS "职务描述",
		# 传递dept_id,交给外层sql使用
		dept_id AS "部门编号"
	FROM 
		emp,job
	WHERE 
		emp.`job_id` = job.`id`) table_emp_job,dept
WHERE table_emp_job.部门编号 = dept.`id`;
```



#### 条件查询

##### 运算符

主要指比较运算符和逻辑运算符

<font color="blue">通过运算符可以限制数据，查询想要的数据</font>

```mysql
# 限制数据范围 > < = != (sql没有==) 
SELECT * FROM student_score WHERE age > 20;

# 20-30 可以用between 20 and 30; (当然用 age>19 and age<31 一样的)
SELECT * FROM student_score WHERE age BETWEEN 20 AND 30;

# 使用and or not 加入逻辑运算(可以用 && || ! 表示)
SELECT * FROM student_score WHERE age = 22 OR age = 18;
SELECT * FROM student_score WHERE address = "湖南" AND sex = "男";

# null不参与比较运算 只能通过逻辑运算判断
SELECT * FROM student_score WHERE english IS NULL;
SELECT * FROM student_score WHERE english IS NOT NULL;
```

---

##### 模糊查询

<font color="blue">但是这些条件只能用来处理数据,可是处理字符串就没辙了；</font>
<font color="blue">比如，表中姓马的有哪些你怎么办？？</font>

<font color="red">这时需要用到模糊查询.</font>

```MYSQL
# 模糊查询 占位符: '%' 任意多个字符 `_` 任意单个字符  
# 模糊查询用占位符来实现对字符串的模糊概括；相比于正则表达式语法更简单,但使用的范围也窄

# 查询'马'开头的name
SELECT * FROM student_score WHERE NAME LIKE "马%";

# 第二个字是'化'的name
SELECT * FROM student_score WHERE NAME LIKE "_化%";

# 包含'化'的name
SELECT * FROM student_score WHERE NAME LIKE "%化%";

# 第三个字是腾
SELECT * FROM student_score WHERE NAME LIKE "__腾";

# 以腾结尾
SELECT * FROM student_score WHERE NAME LIKE "%腾";
```



#### 处理查询结果

在通过条件查询得到我们想要的数据后，还需要对数据进一步处理，使得数据更加间接。

##### 排序

```mysql
# 默认升序排列 排序字段有多个

# 排序 先按english成绩排序，如果相同再比较math
SELECT NAME,english,math FROM student_score ORDER BY english,math;

# 通过 asc(ending) desc(ending) 指定升序 降序
SELECT * FROM student_score ORDER BY math ASC;
SELECT * FROM student_score ORDER BY math DESC;
```

#####  聚合函数

计算"整体"记录的数据

```MYSQL
# 聚合函数对列进行纵向计算，计算结果本身作为一条查询记录存在，返回的rs封装为int

# count 统计一列记录数量 
SELECT COUNT(NAME) AS "学生个数" FROM student_score;		
# 聚合函数计算排除null，要么统计的列没有null，要么使用ifnull处理
SELECT COUNT( IFNULL(english,0) ) AS "英语考生" FROM student_score;	

# 配合条件查询使用 -- 只会统计满足条件的数据 
# 统计男性数量
select count(name) as "男性数量" from student_score where sex = "男";

# 但是注意使用聚合函数的记录只能为1条

## max,min,avg
SELECT MAX(math) AS "数学最高分",MIN(math) AS "数学最低分",AVG(math) AS "数学平均分" FROM student_score;	
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200714115832.png" alt="image-20200714115831090" style="zoom:80%;" align="left"/>

##### 分组 

使用分组之后，数据变成多个"整体"。

所以记录中不应该出现个人的信息，而只能是整体的信息。包括：聚合信息，分组信息。

```mysql
# 分组操作聚合函数
SELECT sex,COUNT(id) AS "人数",AVG(math) AS "数学平均分" FROM student_score GROUP BY sex;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200714162300.png" alt="image-20200714162259846" style="zoom:80%;" align="left"/>



---

如果我们希望对分组进行筛选，需要使用`having`

where在分组之前进行筛选，having则是得到分组记录后筛选分组记录(如果不满足聚合属性不满足就会被去掉)

![image-20220504151034999](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504151035.png)



##### 分页

分段显示记录

```mysql
#limit a,b; 从第a+1条记录开始，每页显示b条；可以省略a默认从第1条开始

# 假设pageSize = 3
SELECT * FROM student_score LIMIT 0,3; -- 第一页

SELECT * FROM student_score LIMIT 3,3; -- 第二页

SELECT * FROM student_score LIMIT 6,3; -- 第三页
#注意：limit是MySQL的方言
```







## 基础补充

### 分页

方式一：

```
select * from table order by id limit m, n;
```

该语句的意思为，查询m+n条记录，去掉前m条，返回后n条记录。无疑该查询能够实现分页功能，但是如果**m的值越大，查询的性能会越低**（越后面的页数，查询性能越低），因为MySQL同样需要扫描过m+n条记录。

方式二：

```
select * from table where id > #max_id# order by id limit n;
```

该查询每次会返回n条记录，却无需像方式1扫描过m条记录，在大数据量的分页情况下，性能可以明显好于方式1，但该分页查询必须要每次查询时拿到上一次查 询（上一页）的一个最大id（或最小id）。该查询的问题就在于，我们有时没有办法拿到上一次查询（上一页）的最大id（或最小id），比如当前在第3 页，需要查询第5页的数据，该查询方法便爱莫能助了。

方式三：

为了避免能够实现方式2不能实现的查询，就同样需要使用到limit m, n子句，为了性能，就需要将m的值尽力的小，比如当前在第3页，需要查询第5页，每页10条数据，当前第3页的最大id为#max_id#：

```
 select * from table where id > #max_id# order by id limit 20, 10;
```

其实该查询方式是部分解决了方式2的问题，但如果当前在第2页，需要查询第100页或1000页，性能仍然会较差。

方式四：

```
 select * from table as a inner join (select id from table order by id limit m, n) as b on a.id = b.id order by a.id;
```

该查询同方式1一样，m的值可能很大，但由于内部的子查询只扫描了字段id，而不是整张表，所以性能要强于方式1查询，并且该查询能够解决方式2和方式3不能解决的问题。

方式五：

```
 select * from table where id > (select id from table order by id limit m, 1) limit n;
```

该查询方式同方式4，同样通过子查询扫描字段id，效果同方式4。至于性能的话，方式5的性能会略好于方式4，因为方式5不需要在进行表的关联，而是一个简单的比较。





## SQL约束

### 非空,唯一,主键

<font color="blue">概念：对表中数据进行限定，保证数据的正确有效和完整</font>

<font color="blue">比如你提交一条记录 name=null,age=18,sex="man";</font>

<font color="blue">显然这样的数据是不完整的，不正确的，无效的；需要被剔除；</font>

<font color="blue">我们需要在对表添加约束条件；</font>

```mysql
# 新建一个学生信息表  添加约束 : 非空，唯一，主键，外键

# 非空约束 NOT NULL
CREATE TABLE student_info(
	id INT,
	NAME VARCHAR(30) NOT NULL-- name非空
);

INSERT INTO student_info(id,NAME) VALUES (001,"张三丰"); -- success
INSERT INTO student_info(id,NAME) VALUES (001,NULL); -- failed


# 唯一约束 UNIQUE
CREATE TABLE student_info(
	NAME VARCHAR(30),-- name非空
	phone_number VARCHAR(20) UNIQUE -- 电话号码不允许重复
);

INSERT INTO student_info(NAME,phone_number) VALUES("张山","18556041926");
# deplicate entry 重复录入
INSERT INTO student_info(NAME,phone_number) VALUES("王五","18556041926"); 


# 主键约束

## 什么是主键 -- 一条记录的唯一标识，主键非空且唯一
## 一张表只能有一个主键
CREATE TABLE student_info(
	id INT PRIMARY KEY, -- ID 主键
	NAME VARCHAR(30)
);
DESC student_info;

INSERT INTO student_info(id,NAME) VALUES(001,"张山");
INSERT INTO student_info(id,NAME) VALUES(NULL,"张山"); # cannot be null
INSERT INTO student_info(NAME) VALUES("张山");         # dose not has adefault value 
INSERT INTO student_info(id) VALUES(002);              # 主键非空，因此默认的null不行，name却是可以的；
INSERT INTO student_info(id) VALUES(002);              # 重复录入


## 自动增长(AUTO_INCREMENT) 主键值的一般做法 自动生成不重复的ID
CREATE TABLE student_info(
	id INT PRIMARY KEY AUTO_INCREMENT, -- ID 主键 自动增长
	NAME VARCHAR(30)
);

# 非空约束的检查是在覆盖值以后检查(数据项是否为null)而不是检查覆盖值是否NULL。
# 这样ID default value = auto_increasement 用null覆盖还是 auto_increasement 不影响；
INSERT INTO student_info(NAME) VALUES("张山");
INSERT INTO student_info(NAME) VALUES("李四");
INSERT INTO student_info(NAME) VALUES("王武");
INSERT INTO student_info(id,NAME) VALUES(NULL,"新江");

#对主键赋值会覆盖自增得到的id
INSERT INTO student_info VALUES(111,"夏天");  

```





### 外键约束

#### 冗余表


```MYSQL
# 创建 员工表 
CREATE TABLE employee(
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(20),
	age INT,
	dep_name VARCHAR(20),    -- 部门名称
	dep_location VARCHAR(20) -- 部门地址
);

DESC employee;

INSERT INTO employee(NAME,age,dep_name,dep_location) VALUES("张三",20,"研发部","广州");
INSERT INTO employee(NAME,age,dep_name,dep_location) VALUES("李四",21,"研发部","广州");
INSERT INTO employee(NAME,age,dep_name,dep_location) VALUES("王五",20,"研发部","广州");
INSERT INTO employee(NAME,age,dep_name,dep_location) VALUES("老王",20,"销售部","深圳");
INSERT INTO employee(NAME,age,dep_name,dep_location) VALUES("老王",20,"销售部","深圳");
INSERT INTO employee(NAME,age,dep_name,dep_location) VALUES("小王",18,"销售部","深圳");

SELECT * FROM employee;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200715132617.png" alt="image-20200715132617493" style="zoom:80%;" align="left"/>

这样的表存在一个问题 ：员工与部门属于一对多的关系；这种方式会导致数据冗余和难以维护的问题；

将不同对象的数据拆分，封装入两张表，然后通过外键的方式相关联(组合).



#### 拆分表

```mysql
# 拆分表 一个员工属于一个部门 员工需要一个部门引用 但是部门不需要引用员工
CREATE TABLE employee(
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(20),
	age INT
);
INSERT INTO employee(NAME,age) VALUES("张三",20);
INSERT INTO employee(NAME,age) VALUES("李四",21);
INSERT INTO employee(NAME,age) VALUES("王五",20);
INSERT INTO employee(NAME,age) VALUES("老王",20);
INSERT INTO employee(NAME,age) VALUES("老王",20);
INSERT INTO employee(NAME,age) VALUES("小王",18);

CREATE TABLE department(
	id INT PRIMARY KEY AUTO_INCREMENT,
	dep_name VARCHAR(20),    -- 部门名称
	dep_location VARCHAR(20) -- 部门地址
);
INSERT INTO department(dep_name,dep_location) VALUES("研发部","广州");
INSERT INTO department(dep_name,dep_location) VALUES("销售部","深圳");

SELECT * FROM employee;
SELECT * FROM department;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200715135244.png" alt="image-20200715135244711" style="zoom:80%;" align="left"/><img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20200715135341.png" alt="image-20200715135341519" style="zoom:140%;" align="left"/>























#### 外键关联 

> 员工表依赖于部门表，员工表附表，部门表是主表。
>
> 当部门表的记录删除，对应的员工表记录也不应该存在。



创建带有外键的表

![image-20201224145555841](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20201224145556.png)



使用之前拆分的表，实现外键关联

```MYSQL
# 添加dep_id
ALTER TABLE employee ADD dep_id INT;

# 在dep_id上增加外键约束
ALTER TABLE employee 
	ADD CONSTRAINT fk_emp_dep FOREIGN KEY (dep_id) REFERENCES department(id);

# 设置dep_id
UPDATE employee SET dep_id = 1 WHERE id = 1 OR id = 2 OR id = 3; 
UPDATE employee SET dep_id = 2 WHERE id = 4 OR id = 5 OR id = 6; 

# 删除外键
ALTER TABLE employee 
	DROP FOREIGN KEY fk_emp_dep;
```



添加外键约束后，删除附表的数据被主表记录引用，因此不能删除。

主表也不能通过外键关联不存在的附表记录。

---

#### 级联操作

由于employee会引用department的记录，

当附表department引用的记录修改(删除)后，需要自动更新到employee，这就是级联操作。

级联操作有两种 1. 级联更新 2. 级联删除

```MYSQL
ON DELETE CASCADE -- 级联删除
ON UPDATE CASCADE -- 级联更新
```

---



要想开启级联操作，可以在创建表时就设置 ,也可以通过DDL开启。

设置级联更新

![image-20201224152921494](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20201224152921.png)



## 多表操作

### 多表关系

1. 多表关系

   1. 分类

      - 一对一(很少,可以直接合并成一张表)

      - 一对多

      - 多对多

   2. 实现方式

      ![image-20210125131825808](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125131825.png)

      

      ![image-20210125132753288](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125132753.png)

      ​		- <font color="blue">id=3记录是非法的因为card.id对应的student.id也是唯一的，这样才是一对一。</font>

      ![ ](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125132425.png)





## 三大范式

![image-20210125192307103](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125192307.png)

- NF - normal form



### 1NF

<font color="blue">看下图</font> 

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125235327.png" alt="image-20210125235327827" style="zoom:80%;" align="left"/>

<font color="blue">这就是违反1NF的一个例子，修改的方法很简单，如下</font>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210125235503.png" alt="image-20210125235502947" style="zoom:80%;" align="left"/>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210309123658.JPG" alt="IMG_1905(20210309-123207)" style="zoom:67%;" />



---

### 2NF

#### <font color="red">存在问题</font>

<font color="blue">但是改完后的表有不少问题。主要如下</font>

```
1. 姓名,系名,系主任 存在数据冗余(重复)
2. 系名和系主任应该并不依赖于学生(学号)而存在，是独立的。
	- 举例，当创建一个新的系的时候如果没有对应的学生，那么就没有合法记录出现在当前的表中
	- 另外，当"张无忌"毕业后，这条记录被删除，那么系的信息也会被删除，这显然不合理。
```

<font color="blue">这就需要引入2NF</font>

#### <font color="red">概念分析</font>

1. **函数依赖**：A-->B , 通过A属性(组)的值，可以唯一(<font color="blue">学号相同，分数值不同这种就是不唯一</font>)确定B属性的值
- 比如*学号-->姓名,课程名称,系名,系主任* ，再比如*(学号，课程名称)-->分数* 
2. **完全函数依赖**：A是确定B的最小属性(组)，则称B完全依赖于A

   - 比如*(学号,系名)-->姓名*，就不是完全依赖，而称为**部分函数依赖**(<font color="blue">只依赖于一部分属性</font>)。

3. **传递函数依赖**：A-->B B-->C C依赖于B，B依赖于A，则C传递依赖于A
- *学号-->系名-->系主任*
4. **(候选)码**：该表的所有其他属性完全依赖于A属性(组)

   - 码中的属性称为**主属性**，其余称为**非主属性**。

   - 分析表的属性我们发现：（F表示完全依赖，F表示部分依赖）
     - *学号-F->姓名,系主任,系名* 
     - *(学号,课程名称)-P->分数*
     - 即*(学号,课程名称)-P->姓名,系主任,系名,课程名称,分数*,但是并不是完全函数依赖。
     - 这意味着这张表需要<font color="blue">消除</font>*(姓名,系主任,系名)*<font color="blue">对</font>*(学号,课程名称)*<font color="blue">的部分依赖</font>

---

#### <font color="red">消除部分依赖</font>	

将部分依赖的属性和码投影为新表，原表中删除部分依赖的属性

![2NF](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504171043.png)

![image-20210126005515041](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126005515.png)

<font color="blue">t_enrolled 自然连接 t_student就可以得到拆分之前的表</font>



还存在传递依赖



---

### 3NF 

- 任何非主属性不依赖于其他非主属性(消除传递依赖)

存在 *学号-->系名-->系主任* 这样一个传递依赖关系。



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126020139.png" alt="image-20210126020139406" style="zoom:67%;" align="left"/>



移除传递依赖的属性，选择系名作为外键，这样就解除了学生与系之间的耦合

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210309124729.JPG" alt="IMG_1909(20210309-124410)" style="zoom:67%;" />

## 数据库备份与还原

- cmd操作

![image-20210126141741568](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126141741.png)

- 图形界面是一样的流程，略。

---

## 多表查询



### 内连接

将两张表的所有记录组合，就可以得到笛卡尔积。

```MYSQL
SELECT * FROM employee,department; -- 笛卡尔积
```



求得笛卡尔积后，去除没有匹配行的部分。

这种连接被称为：自然连接（内连接），在mysql中有两种实现方式 1. 隐式 2.显式 只是语法上的区别

```mysql
# 隐式内连接 ： 使用where过滤无效数据
SELECT 
	# 通过table.column区别两张表的冲突字段
	employee.`id`,employee.`name`,age,dep_name,dep_location 
FROM 
employee,department 
WHERE 
	employee.`dep_id` = department.`id`;

# 显式内连接 ： 使用join-on过滤无效数据
SELECT 
	employee.`id`,employee.`name`,age,dep_name,dep_location 
FROM 
	employee
# 此处inner可以省略	
INNER JOIN 
	department
ON 	
	employee.`dep_id` = department.`id`;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504174047.png" alt="image-20220504174047409" style="zoom:80%;" align="left"/>



### 外连接

外连接（outer join）: 与内连接的区别在于，外连接不仅返回匹配的行，也会返回不匹配的行。

这样可以防止信息缺失，比如：某一个员工的部门为null，内连接不会显示员工记录，而外连接会显示。

> employee.dep_id != department.id 存在四种情况
>
> 1. 都不为null，不匹配      应该丢失
> 2. department.id = null    左外连接，不应该丢失
> 3. employee.dep_id = null         右外连接，不应该丢失
> 4. 都为null                          全外连接，不应该丢失



```JAVA
# 外连接 -- 一般使用左外连接
SELECT 
	employee.`id`,employee.`name`,age,dep_name,dep_location 
FROM 
	employee 
LEFT JOIN 
	department 
ON
	employee.`dep_id` = department.`id`;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504190333.png" alt="image-20220504190333617" style="zoom:80%;" align="left"/>

### 子查询

#### 入门案例

有这么一张表:

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126182621.png" alt="image-20210126182621719" style="zoom:80%;" align="left"/>

我们需要查询最高工资员工的信息

一种不太优雅的做法如下：

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126182750.png" alt="image-20210126182750158" style="zoom:80%;" align="left"/> 





将其合并为一条语句，这就是子查询

> 使用内层语句的查询结果，作为外层语句的参数。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126182904.png" alt="image-20210126182903951" style="zoom:80%;" align="left" />

---

#### 子查询结果的不同情况

1. 单行单列 : 作为属性值参与条件运算

   ![image-20210808202545984](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210808202547.png)

2. 单列多行(子查询结果是一个集合): 使用in作为条件使用

   ![image-20210126200409030](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126200409.png)

   > 
   >
   > ```MYSQL
   > # in的基本使用
   > 
   > # 符合条件的数据是一个集合时
   > select * from table where id = 1 OR id = 2 Or id = 3;
   > 
   > # 使用in简化操作 
   > select * from table where id in(1,2,3); 
   > 
   > # 在此基础上使用子查询得到集合，再使用in
   > ```

3. 多行多列

   查询结果作为虚拟表与其他表进行自然连接

   <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210126202306.png" alt="image-20210126202306017" style="zoom:80%;" align="left" />

---

### 练习

SQL如下

```sql
-- 部门表
CREATE TABLE dept (
  id INT PRIMARY KEY PRIMARY KEY, -- 部门id
  dname VARCHAR(50), -- 部门名称
  loc VARCHAR(50) -- 部门所在地
);

-- 添加4个部门
INSERT INTO dept(id,dname,loc) VALUES 
(10,'教研部','北京'),
(20,'学工部','上海'),
(30,'销售部','广州'),
(40,'财务部','深圳');


-- 职务表，职务名称，职务描述
CREATE TABLE job (
  id INT PRIMARY KEY,
  jname VARCHAR(20),
  description VARCHAR(50)
);

-- 添加4个职务
INSERT INTO job (id, jname, description) VALUES
(1, '董事长', '管理整个公司，接单'),
(2, '经理', '管理部门员工'),
(3, '销售员', '向客人推销产品'),
(4, '文员', '使用办公软件');



-- 员工表
CREATE TABLE emp (
  id INT PRIMARY KEY, -- 员工id
  ename VARCHAR(50), -- 员工姓名
  job_id INT, -- 职务id
  mgr INT , -- 上级领导
  joindate DATE, -- 入职日期
  salary DECIMAL(7,2), -- 工资
  bonus DECIMAL(7,2), -- 奖金
  dept_id INT, -- 所在部门编号
  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),
  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)
);

-- 添加员工
INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES 
(1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20),
(1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30),
(1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30),
(1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20),
(1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30),
(1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30),
(1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10),
(1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20),
(1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10),
(1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30),
(1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20),
(1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30),
(1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20),
(1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10);



-- 工资等级表
CREATE TABLE salarygrade (
  grade INT PRIMARY KEY,   -- 级别
  losalary INT,  -- 最低工资
  hisalary INT -- 最高工资
);

-- 添加5个工资等级
INSERT INTO salarygrade(grade,losalary,hisalary) VALUES 
(1,7000,12000),
(2,12010,14000),
(3,14010,20000),
(4,20010,30000),
(5,30010,99990);
```



需求如下

```
-- 需求：



-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置
   
-- 3.查询员工姓名，工资，工资等级

-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级

-- 5.查询出部门编号、部门名称、部门位置、部门人数
 
-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询

```



实现1

```MYSQL
-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述
SELECT 
	emp.`id` AS "员工编号",
	emp.`ename` AS "员工姓名",
	emp.`salary` AS "工资",
	job.`jname` AS "职务名称",
	job.`description` AS "职务描述"
FROM 
	emp,job
WHERE 
	emp.`job_id` = job.`id`;
```

![image-20220504192831381](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504192831.png)



实现2 : 

1. 第一种方式，在实现1的基础上，使用子查询;
2. 第二种方式，三个表一起内连接

```MYSQL
-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置

-- 使用子查询，实现自然连接

SELECT 
	员工编号,员工姓名,工资,职务名称,职务描述,dname AS "部门名称",loc AS "部门位置"
FROM 
	(SELECT 
		emp.`id` AS "员工编号",
		emp.`ename` AS "员工姓名",
		emp.`salary` AS "工资",
		job.`jname` AS "职务名称",
		job.`description` AS "职务描述",
		# 传递dept_id,交给外层sql使用
		dept_id AS "部门编号"
	FROM 
		emp,job
	WHERE 
		emp.`job_id` = job.`id`) table_emp_job,dept
WHERE table_emp_job.部门编号 = dept.`id`;
   
-- 简化 直接对三个表做笛卡尔积,然后通过where实现内连接
-- 这么写不能做过多的控制(比如控制谁与谁先外连接)
SELECT 
	emp.`id` AS "员工编号",
	emp.`ename` AS "员工姓名",
	emp.`salary` AS "工资",
	job.`jname` AS "职务名称",
	job.`description` AS "职务描述",
	dept.`dname` AS "部门名称",
	dept.`loc` AS "部门位置"
FROM 
	emp,job,dept
WHERE
	emp.`dept_id`=dept.`id` AND emp.`job_id`=job.`id`;
```

![image-20220504195609493](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504195609.png)





实现3

```MYSQL
-- 3.查询员工姓名，工资，工资等级
-- 使用自然连接(没法子查询,t2需要t1的参数,通过合并表的方式，让t2与t1处于同一张表后，自然就能拿到需要的数据)
-- select emp.name as "员工姓名",emp.`salary` as "工资" , (
	# 确定当前的工资
-- 	SELECT grade FROM salarygrade WHERE emp.`salary` BETWEEN losalary AND hisalary;
-- ) as "工资水平" from emp; 

SELECT 
	emp.`ename` AS "员工姓名",
	emp.`salary` AS "员工工资",
	salarygrade.`grade` AS "工资等级"
FROM
	emp,salarygrade
WHERE 
	emp.`salary` BETWEEN salarygrade.`losalary` AND salarygrade.`hisalary`;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504201849.png" alt="image-20220504201849270" style="zoom:80%;" align="left"/>



实现4

```MYSQL
-- 合并四张表
SELECT 
	emp.`id` AS "员工编号",
	emp.`ename` AS "员工姓名",
	emp.`salary` AS "工资",
	job.`jname` AS "职务名称",
	job.`description` AS "职务描述",
	dept.`dname` AS "部门名称",
	dept.`loc` AS "部门位置",
	salarygrade.`grade` AS "工资等级"
FROM 
	emp,job,dept,salarygrade
WHERE 
	emp.`dept_id`=dept.`id` AND emp.`job_id`=job.`id` AND emp.`salary` BETWEEN salarygrade.`losalary` AND salarygrade.`hisalary`;
```

> 获取到不同表中的数据，就是通过内连接，没有其他途径。



实现5

首先分组统计

```mysql
-- 5.查询出部门编号、部门名称、部门位置、部门人数
-- 部门人数，在emp表中使用group by分组count统计
SELECT 
	dept_id AS "部门名称",COUNT(id) AS "部门人数"
FROM
	emp
GROUP BY dept_id;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504202922.png" alt="image-20220504202922693" style="zoom:80%;" align="left"/>

然后通过内连接补充其他信息

```mysql
SELECT 
	t2.id AS "部门编号",
	t2.dname AS "部门名称",
	t2.`loc` AS "部门位置",
	t1.cnt AS "部门人数"
FROM
	(SELECT 
		dept_id ,COUNT(id) AS cnt
	FROM
		emp
	GROUP BY dept_id) t1, dept t2
WHERE t1.dept_id = t2.id;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504203603.png" alt="image-20220504203603390" style="zoom:80%;" align="left"/>





实现6

```MYSQL
-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询
-- 上级字段指emp.magr
-- 通过自连接，将上级与员工匹配到同一张表 
SELECT 
	t1.`ename` AS "员工姓名",
	t2.`ename` AS "上级姓名"
FROM
	# t1 表示员工 t2代表上级
	emp t1
LEFT JOIN 
	emp t2
ON 
	t1.`mgr` = t2.`id`;
```

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504204230.png" alt="image-20220504204230390" style="zoom:80%;" align="left"/>

---





## 事务

### 事务介绍

![image-20220504204535456](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220504204535.png)

### 事务操作

比如,在银行转账这个业务中,要么两个人的账户余额通过修改,要么不修改,不能一个转账,另一个没到账

  ```mysql
-- 创建账户表
CREATE TABLE account(
	a_id INT PRIMARY KEY AUTO_INCREMENT,
	a_name VARCHAR(10),
	a_balance DOUBLE
);

-- bu插入两条记录 
INSERT INTO account (a_name,a_balance) VALUES ('张三',1000) ,('李四',1000);

-- 1. tom转出500
UPDATE account SET a_balance = a_balance - 500 WHERE a_name = 'tom';

-- 2. jerry转入500
UPDATE account SET a_balance = a_balance + 500 WHERE a_name = 'jerry';

SELECT * FROM account; -- tom 500 jerry 1500
-- 还原
UPDATE account SET a_balance = 1000;

-- 0. 开启事务 
START TRANSACTION;
-- 转账操作
UPDATE account SET a_balance = a_balance - 500 WHERE a_name = 'tom';
-- 加入异常

UPDATE account SET a_balance = a_balance + 500 WHERE a_name = 'jerry'; -- failed

-- 出现问题 tom 500 jerry 1000回滚事务
-- 将状态恢复到start transaction 之前
ROLLBACK;

-- 如果没有问题 提交 
COMMIT;


  ```

### 关闭自动提交

mysql数据库默认自动提交 (oracle默认手动提交)

- 一条DML(增删改)语句会自动提交一次事务 -- 即数据持久化更新 

```mysql
select @@autocommit -- 1 表示开启了自动提交
set autocommit = 0  --   关闭自动提交
```



​     

### 事务四大特征

1. 原子性：是不可分割的最小单位，要么同时成功，要么同时失败
2. 持久性：当事务回滚或者提交后，数据库会持久化的保存数据
3. 隔离性：多个事务间相互独立
4. 一致性：事务操作前后，数据总量不变



### 事务的隔离级别

#### 概念

多个事务之间相互独立，但是当不同的事务操作同一块数据时会引发问题。

这时设置不同的隔离级别就可以解决这些问题

#### 问题

1. 脏读：一个事务读取到另一个事务没有提交的数据
2. 不可重复读(虚读)：同一个事务中，，两次读取的数据不一样
3. 幻读：第一个事务操作修改了表中的所有记录，第二个事务添加了一条记录，则第一个事务查询不到自己的修改(ABA  )

#### 隔离级别

1. read uncommitted
   - 产生问题  脏读，不可重复读，幻读
2. read commited（oracle默认）
   - 不可重复读，幻读 -- 消除脏读
3. repeatable read（mysql默认）
   - 幻读 -- 消除出虚读
4. serializable: 串行化 -- 消除幻读
   - 解决所有问题
5. 隔离级别从小到大，安全性越来越高，效率越来越低

#### 设置隔离级别

`set global transaction isolation level `





## DCL_用户管理

不看







# MYBATIS

> 笔记在[语雀](https://www.yuque.com/kangyin-2fcso/twkvol/wkr7hg)上
>
> 项目本地路径 javaee-workspace/learn-mybatis



---

