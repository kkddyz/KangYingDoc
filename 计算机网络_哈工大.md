前言~思考

>网课与书本的区别
>
>网课应该力求简单，以便将课程的知识体系以一种明晰的方式呈现出来。它提供的是一个简单通用的用于认知的模板。通过网课学生可以在最短的时间内具备回答最基础的问题的能力。
>
>
>
>而一本书它的信息量远远大于网课，它记录更多的细节。以一种更加严谨乃至面面俱到的方式组织相关的知识。而这恰恰是读书的难点：如何从书中提取不同层次的知识：基础的，进阶的，高深的；重要的，不重要的；易懂的，晦涩的。正是由于书本中信息的复杂度之高，我们往往采用"反刍式"的方式来吃透一本书。但是这样的一本书对于初学者而言营养丰富却难以消化。
>
>
>
>所以，我学习网课往往是做一遍笔记来获取其中的所有信息。然后在此基础上去有针对性的阅读书籍。



# 第一周 计算机网络的基本概念



> 网络概念，模型
>
> Internet概念，模型 
>
> 接入网络方式
>
> 数据交换方式 -- 分组交换

## 1.1.1 计算机网络与Internet

### 什么是计算机网络？

---

<font color="blue">a:计算机网络是一种通信网络(从本质上理解)</font>

![image-20210306144450098](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306144450.png)

---

<font color="blue">b:计算机网络是<font color="red">互连的</font>，<font color="red">自治的</font>网络集合</font> (**定义**)

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306145218.png" alt="image-20210306145218473" style="zoom:50%;" align="left"/>



---

**疑问如果网络中的主机数量非常之大，网络关系十分复杂，该如何实现这张图的联通？**

<font color="blue">显然我们不可能通过直接链路(接一条线到某个主机)实现。</font>

为此我们引入一个概念：***交换网络***

![image-20210306145739442](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306145739.png)

主机通过与交换网络相连，间接实现主机之间的互联。



***交换节点*** :<font color="blue">交换网络的nuts and bolts</font>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306145855.png" alt="image-20210306145855497" style="zoom:50%;" align="left"/>



---



### 什么是Internet?

#### 从它的**组成**来看

<font color="blue">Internet是由*ISP网络*互联的"网络之网络" ,是全球最大的*计算机网络*。</font>

##### 图像描述

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306150929.png" alt="image-20210306150929862" style="zoom:80%;" align="left"/>

其中的连线与节点表示链路

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306151530.png" alt="image-20210306151530855" style="zoom:67%;" align="left"/>



> *ISP : Internet Service Provider 互联网服务提供商*
>
> *End System 端系统 : 广义上指所有接入互联的设备，即上图的Key.每个端系统都运行各种网络应用。*

---

#### 从它提供的服务来看

<font color="blue">Internet是为网络应用提供通信服务的基础设施，网络应用通过Internet提供的API使用Internet.</font>



很简单，就是上面从本质层面理解计算机网络。

---

### 问题：引入协议

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306152229.png" alt="image-20210306152228924" style="zoom: 33%;" align="left" align="left" />





---



## 1.1.2	网络协议



### 什么是网络协议？

<font color="blue">网络协议(network protocol),是网络中数据交换必须遵守的<font color="red">规则,标准,约定</font></font>

**<font color="blue">硬件是计算机网络的基础，而协议是计算机网络<font color="red">有序运行</font>的重要保证。</font>**

---

### 协议的三要素

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306165703.png" alt="image-20210306165703017" style="zoom:67%;" align="left"/>



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306170013.png" alt="image-20210306170012939" style="zoom:67%;" align="left"/>

---

>**RFC**
>
>RFC文件是由Internet Society（ISOC）赞助发行。基本的互联网通信协议都有在RFC文件内详细说明。RFC文件还额外加入许多在标准内的论题，例如对于互联网新开发的协议及发展中所有的记录。*因此几乎所有的互联网标准都有收录在RFC文件之中。*
>
>**IETF**
>
>互联网工程任务组（The Internet Engineering Task Force，简称 IETF）是一个公开性质的大型民间国际团体，汇集了与互联网架构和互联网顺利运作相关的网络设计者、运营者、投资人和研究人员，并欢迎所有对此行业感性趣的人士参与。*IETF的主要任务是负责互联网相关技术标准的研发和制定，是国际互联网业界具有一定权威的网络相关技术研究团体。*



*补充理解*（很精辟，基本上背上就可以说出本节的内容）

网络协议是在网络上通信的双方必须遵守的一些约定和规则，只有双方都遵守这些内容才能正常的建立连接交流。

网络协议的三要素是

- 语法：用来规定数据传输的格式和内容。-- 写信的格式

- 语义：说明通信双方该怎么做，用来协调和解决信息差。 -- 具体内容(交流的信息)

- 时序：用来表明应该做那些动作，和动作的先后顺序。

网络通信过程是计算机完成的，网络协议只不过是交流的一些规则，不代表过程本身。

---

> 1.1.1&&1.1.2 描述了网络的概念，1.2.1&&1.2.2 描述了网络的模型。
>
> 上面讲了什么是网络，以及网络协议。
>
> 下面则讲了网络的具体实现



---

》、

## 1.2.1 计算机网络结构

### 网络组成 (重点)

<font color="blue">计算机网络的组成结构</font>

- **网络边缘**：主机
- **接入网络（物理介质）**：有线或者无线通信链路
-  **网络核心** ：路由器，交换机



---

### 网络应用模型（了解）

<font color="blue">位于网络边缘的网络应用程序通过网络实现通信。</font>应用通信的实现有两种模型：

1. Client/Server 应用模型：如web,FTP
2. 对等应用模型(peer-peer,P2P):如QQ
   - 特点：不依赖专用服务器，通信在**对等**实体之间直接进行

---

### 接入网络 (了解)

1. 接入网络的分类

   <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306172525.png" alt="image-20210306172525271" style="zoom:33%;" align="left" />

2. 用户关心点

   - 带宽 bandwidth bps
   - 带宽是共享/独占 ？

    

最关键的问题是如何将边缘网络接入核心网（边缘路由器）

下面介绍不同的接入网络的实现(仅作了解)



#### DSL 数字用户线路 

- Digital subscriber line 

![image-20210306173935065](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306173935.png)

*简单的说利用原来的电话网络，通过多路复用技术同时传输声音与网络数据。*

*用户这里通过分离器，将两种不同的信号分离，通过DSL调制解调器解析网络数据。*

*中心局以相同的方式得到用户上传的网络数据，接入ISP网络。*



FDM:简单来说，不同频率用于传输不同数据。这样即使通过同一根电话线传输混合的数据也可以区分。

> DSL接入复用器（Digital Subscriber Line Access Multiplexer）
>
> ADSL A非对称,指upload与download速度不一样；
>
> FDM abbr. 频分多路复用（frequency-division multiplexing）

---

#### HFC混合光纤电缆

> 我们电视调台的本质是切换接受信号的频率，已经使用了FDM技术
>
> 下面那张频道示意图想表达的就是这个意思

![image-20210306174326910](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306174327.png)

---

> HFC F光纤部分是ISP网络 同轴电缆就是

![image-20210306174800617](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306174800.png)

> 由于是共享的所以网速不一定比独占的DSL快



---

![image-20210306175311023](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306175311.png)

---

#### 企业接入网络	

![image-20210306183346615](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306183346.png)

---

#### 无线接入网络

![image-20210306183550633](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306183550.png)



---

### 网络核心(重点)

![image-20210306183946511](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306183946.png)



> 路由 routing 转发 forwarding ，即寻路和跳转

下面是router的示意图

![image-20210306184459224](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306184459.png)



---

### 问题：引入数据交换



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306192643.png" alt="image-20210306192643841" style="zoom:67%;" align="left"/>

我们知道通过router确定路径，可以将数据交给另一个router。

问题在于如何实现两个router之间的数据传输，即研究网络核心的实现细节。

> 网络中的数据交换采用分组交换

---

## 1.2.2Internet结构

ISP提供互联网服务，它的实体就是网络结构中的接入网络+网络核心。

接入ISP + 接入的端系统 ==> 完整的网络。

接入ISP ==> access net,是局域网，它通过接入更大的ISP与其它的access net建立连接。

access net 指的就是作为internet边缘的接入ISP网络。



在Internet的结构中，每个*接入ISP*作为*更高级ISP*网络的*网络边缘*存在

![image-20210306190747113](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306190747.png)





![image-20210306191637520](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306191637.png)

![image-20210306191647590](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306191647.png)



![image-20210306192019235](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306192019.png)

![image-20210306192131443](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306192131.png)

> internet的结构不是硬件结构，而是一种体系上的逻辑上的结构。

---

## 1.3.1 数据交换方式(了解)

数据交换出现的必要性：

1. 在端系统之间直接建立网络链路连接会导致需要维护的链路数量太过庞大。
2. 单个交换设备的端口有限，只能组建起小规模的网络

交换设备通过数据交换技术构成交换网络，逻辑上的交换设备。

![image-20210306193654549](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306193654.png)

---

### 电路交换

![image-20210306195618810](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306195618.png)

![image-20210306195735048](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306195735.png)



### 多路复用

- 简称复用，是通信技术中的基本概念

![image-20210306200042181](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306200042.png)

- 共享信道的传输速度A,b,c上的传输速度。

##### 原理：

1. 将链路/网络资源(如带宽)划分为 **资源片**

2. 将资源片分配给各路呼叫（calls）

3. 每路呼叫*独占*分配到的资源片进行通信。
4. (由于是分配好的,所以)会出现资源片*闲置（idle）*的情况.

##### 典型的多路复用方法

FDM TDM WDM CDM

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306200623.png" alt="image-20210306200623312" style="zoom:50%;" align="left"/>

---

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306200715.png" alt="image-20210306200715356" style="zoom:50%;" align="left"/>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306200816.png" alt="image-20210306200816787" style="zoom:50%;" align="left"/>

---

![image-20210306201032287](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306201032.png)

---

![ ](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306201125.png)

![image-20210306201151130](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306201151.png)

---

![image-20210306201918400](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306201918.png)

> 感觉不是重点，需要补线代的知识，我又不是通信工程专业的。

---

### 报文交换

![image-20210306202230171](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306202230.png)

- 实例：电报



---

### 分组交换(重点)

- packets switching 数据包交换

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306202547.png" alt="image-20210306202547206" style="zoom: 50%;" align="left"/>

#### 过程

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306202746.png" alt="image-20210306202745954" style="zoom:33%;" align="left" />

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306202658.png" alt="image-20210306202658265" style="zoom:33%;" align="left"/>



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306203230.png" alt="image-20210306203230044" style="zoom:33%;" align="left" />

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306202932.png" alt="image-20210306202932854" style="zoom:33%;" align="left"  />



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306203153.png" alt="image-20210306203153093" style="zoom:33%;" align="left"/>



#### 共享链路：统计多路复用	

![image-20210306203414894](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306203415.png)

> 感觉bandwidth带宽和戴森球里的传送带很相似

---

### 报文交换VS分组交换

![image-20210306203730481](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306203730.png)



下面从不同的方面来讨论一下两者的优劣

---

#### 传输时延 delay

- 即报文开始发送到发送结束的时间差



##### 分组传输时延

![image-20210306204740346](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306204740.png)



##### 情景分析

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306205417.png" alt="image-20210306205417252" style="zoom:80%;" />

![image-20210306211346897](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306211347.png)

分组交换是并行发生的每次传输多个packet，而报文相当于每个单位时间只传输一个包。

在这个例子中时间分别为 15s 5.002s



<font color="blue">同时分组传输需要的缓存也大大降低。</font>

---

##### 情景推广

![image-20210306211512461](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306211512.png)

---

![image-20210306212310982](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306212311.png)

> 脑子不好使了，已经，我不太明白的就是电路交换的共享和它占用线路时不能资源共享的矛盾。
>
> 以时分复用为例，假设假设将线路每帧分给n个用户，那么对于用户而言实际的bps只有原来的1/n，这是一种平均分配。
>
> 我懂了，电路交换的共享实质是分配资源片，用户共享了同一个链路，但是不共享链路的传输资源，即bps。





---

采用分组交换，链路中混合着不同源的数据包，

![image-20210306213214917](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210306213215.png)

讲的不太清楚，也不是重点。

----

# 第二周

## 1.4 计算机网络性能

---

### 速率

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210312193626.png" alt="image-20210312193626646" style="zoom:67%;" align="left"/>



- 速率往往是**额定速率**或者**标称速率** ，即理想状态下的速率。

---

### 带宽

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210312194034.png" alt="image-20210312194034386" style="zoom:67%;" align="left" />

---

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210312194545.png" alt="image-20210312194545065" style="zoom:67%;" align="left"/>	























---

### 时延

#### 四种分组延迟

电脑传输数据

首先需要交给节点处理，确定一下输出链路；(很短)

然后就是排队等，前面的分组被转发出去。

轮到你的时候，节点转发数据需要一定时间。(固定值)

最后，数据通过传输介质到达目的地也需要一定时间。(固定值)

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210312194717.png" alt="image-20210312194717004" style="zoom:67%;" align="left"/>

- 现在路由器的处理能力很强，基本只有毫秒级的延迟。

---

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210312194847.png" alt="image-20210312194847509" style="zoom:67%;" align="left" />

---

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210312194930.png" alt="image-20210312194930695" style="zoom:67%;" align="left"/>

---

#### 排队延迟

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210312195233.png" alt="image-20210312195233265" style="zoom:67%;" align="left" />

---

### 时延带宽积

- 传播时延 * 带宽

![image-20210321140256210](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321140256.png)

- <font color="blue">传播介质中运输的信息量</font>，单位为bit
- 又称为**以bit为单位的链路长度**

---

### 丢包率

![image-20210321140710280](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321140710.png)

---

### 吞吐量  

![image-20210321140807706](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321140807.png)



吞吐量取决于**瓶颈链路**：端到端上速率最慢的链路	

---

![image-20210321141316002](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321141316.png)

---

## 1.5 计算机网络体系结构

---

### 分层模型

#### 出现的必要性

<font color="red">出现的需求：为复杂的计算机网络系统，提供一种简单有效的描述结构，以便讨论计算机网络的相关问题。</font>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321142656.png" alt="image-20210321142656568" style="zoom:50%;" align="left"/>

---

- 分层可以简单理解为分步，将一个大的任务分为一个个小任务。

---

<font color="blue">计算机网络结构是从<font color="red">功能上(逻辑而非物理层面)</font>描述计算机网络结构</font> 

<font color="blue">分层结构中，每层<font color="red">遵循某些协议</font>实现本层功能</font>

<font color="red">计算机网络体系结构</font>, <font color="blue">是计算机网络的各层及其协议的集合</font>

---

#### 分层模型的优点

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321143820.png" alt="image-20210321143820344" style="zoom:50%;" align="left"/>

---

##### 存在问题

过多的分层会降低系统的效率，最典型的政务处理系统。

---

### 分层体系结构的基本概念

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321184219.png" alt="image-20210321184219407" style="zoom:50%;" align="left" />

> 透明的意思是看不见，即黑盒，不是日常用语中的透明：毫无隐藏。

---

### OSI参考模型

> *OSI (open system interconnect)*,是由国际标准化组织(ISO)于1984年提出的分层网络体系结构模型。
>
> 目的是支持**异构网络系统的互联互通** ，成为了异构网络系统互联的<font color="blue">国际标准</font>
>
> 但是它仅仅作为理解网络通信的最佳<font color="blue">学习工具</font>,市场则是失败的。
>
> 异构的意思是不同的网络。



#### **模型图示**

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321185147.png" alt="image-20210321185147733" style="zoom:80%;" align=left />

---

#### OSI模型通信过程

![image-20210321185800964](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321185801.png)



我们可以发现从应用层到传输层不存在中间系统.

![image-20210321190255053](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321190255.png)

---

#### OSI模型数据封装

![image-20210321191523185](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321191523.png)

> PDU protocol digital unit 协议数据单元
>
> H head T tail ； 每层都会有一个H作为控制信息

---

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321191954.png" alt="image-20210321191953816" style="zoom: 50%;" align="left"/>



### OSI底层模型

#### 物理层

- 解决单一bit传输的功能 

![](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321194420.png)



> 半双工(half-duplex)： 交替单工 : 对讲机 

---

#### 数据链路层

发送一个数据帧到物理层 <font color="gray">从数据流中"切出"数据帧。</font>

物理层只是负责传输bit这一功能，而链路层则需要保证将相连节点之间的数据传输的正确性。



![image-20210321200921708](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321200921.png)

---

##### **物理寻址**

![image-20210321201303806](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321201303.png)

<font color="blue">确保数据帧被正确的主机接受。</font>

---

##### **流量控制 flow control** 

<font color="blue">匹配发送端和接收端的速度，避免发送端的数据淹没接收端(缓存不够用)</font>

---

##### **差错控制 error control** 	

检测并重传损坏帧或丢失帧，避免重复帧

---

##### **访问控制 access control**

(在多台设备共享物理介质通行时),在任意给定的时刻决定哪台设备拥有*链路*（物理介质）*控制使用权*

---

#### 网络层

---

##### **逻辑地址**

<font color="blue">网络层负责源主机到目的主机的分组packet交付</font>,在这个过程中可能穿越多个网络，此时无法通过链路层的物理地址来**唯一确定**主机的位置。

所以我们需要一个**全局唯一**的**逻辑地址**标识主机，确保数据分组可以到达目的主机，如IP地址。

---

##### **routing 路由**

路径选择

---

##### **转发**

![image-20210321203738783](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321203738.png)

从图中看出网络层跨越了多个链路实现数据的转发。

---

### OSI端到端模型

#### 传输层

![image-20210321205053804](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321205053.png)

<font color="blue">负责源-目的（端-端） （进程间）完整报文传输</font>



##### **分段重组**

##### **SAP寻址**

确保将报文提交给正确的**进程**，如端口号 

![image-20210321205504298](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321205504.png)

- 传输层的S-PDU中包含进程地址即x,y。

---

**连接控制**

**流量控制**

**差错控制**

---

#### 会话层

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321210014.png" alt="image-20210321210014031" style="zoom:50%;" align="left" />

- 在现在的网络模型中不作为单独一层存在。

---

#### 表示层

![image-20210321210240571](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210321210240.png)

---

不同系统对数据的表示可能不同

---

##### **数据表示转化**

- 转化为主机独立的编码

**加密解密**

**压缩解压缩**

---

表示层一般并到应用层中

---

#### 应用层

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210323164027.png" alt="image-20210323164027573" style="zoom: 50%;" align="left"/>

----

### TCP/IP参考模型

> 与OSI参考模型现有理论再去实现模型的情况不同，TCP/IP参考模型是根据现有的网络总结出来的模型。
>
> 在这个模型中将具体的协议作为实体，分为4层，相比于OSI模型，省略了表示层，会话层，隐藏了链路，物理层。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210323164158.png" alt="image-20210323164158319" style="zoom:50%;" align="left" />



---

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210323164926.png" alt="image-20210323164925965" style="zoom: 33%;" align="left"/><img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210323165144.png" alt="image-20210323165144781" style="zoom:33%;" />



所有的应用都架设在IP之上，IP应用于各种(底层)网络。

---

### 5层参考模型

> TCP/IP参考模型的优点：**实用**(Internet就是这样做的，实际网络就是如此运行)。 
>
> OSI参考模型的优点：将网络的概念模型分析的非常清楚
>
> 5层参考模型将二者结合，是当前研究网络最常用的模型。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210323165730.png" style="zoom:50%;" align="left"/>

---

#### 数据封装

 <img src="D:\QQ\QQDATA\2387811469\FileRecv\MobileFile\26601A813886CE1966C536AFD1F1A7DD.png" alt="26601A813886CE1966C536AFD1F1A7DD" style="zoom:50%;" align="left"/>

> 应用层将完整message交给传输层，传输层将报文分段为segment交给网络层封装为datagram流入链路层成为frame.

> 从这个模型可以看出交换机和路由器的区别，交换机只负责将链路层的frame通过物理寻址交给相连的主机；路由器则需要通过ip寻址，跳转到下一个节点。

---

## 1.6 计算机网络的发展史

> 1962-1972：早期分组交换原理的提出与应用。
>
> 1972-1980：网络互联，大量新型，私有网络出现。
>
> 1980-1990：新型网络协议与网络的激增。
>
> 1990-2000`s: 商业化，web，新应用
>
> 2005-今

**示意图：**

![image-20210323171341079](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210323171341.png)

---

> MOOC-计算机网络-哈工大[视频链接](https://www.icourse163.org/learn/HIT-154005?tid=1463162470#/learn/content?type=detail&id=1240421272&cid=1261896486)

---

# 第三周 网络应用

## 2.1 网络应用层概述

## 2.2 网络应用的基本原理

## 2.3 web应用

### 2.3.1web应用概述 

![image-20210323171811543](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210323171811.png)

### 2.3.2 http连接类型



![image-20210323185054507](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210323185054.png)

持久性连接，避免了每次建立连接所需的1RTT.

---

### 2.3.3 http消息格式





### 2.3.4 Cookie技术



---

### 2.3.5 web缓存/代理服务器技术

功能：在不访问服务器的前提下满足客户端的HTTP请求

---

#### 为什么要发明这种技术？？

- 缩短客户请求的响应时间
- 减少机构/组织的流量
- 在大范围内(Internet)实现有效的内容分发






---

第三章web应用在我看来是属于计网知识体系边缘的内容，TCP/IP才是重点。

所以，我直接跳过第三章了。

PS:第三章Socket编程很有用要看。



# Socket编程

## 网络程序设计接口

对于每一层有不同的编程方式

web编程实际上是在web应用的基础上做开发，socket是在传输层的基础上开发。

Socket编程就是使用传输层的api，向上层：应用层提供服务。

![image-20220430103435343](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220430103435.png)

## 应用编程接口

![image-20211017163155202](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220430105943.png)

> 应用编程接口API,是一类网络程序设计接口。
>
> 它面向系统控制的传输层，为用户控制的应用层提供服务。
>
> 应用进程之间的通信遵循应用层协议，而信息交互本身依赖传输层实现。应用层和传输层之间，显然需要交互。操作系统之上的应用进程和操作系统之内的传输层协议之间的交互，又显然需要一个接口。
>
> 这个接口就是应用编程接口API.对于网络应用程序，就是网络API.
>
> 这些API通过系统调用在应用程序的控制权和操作系统之间的控制权做转换。



> 网络API中典型的有(最广泛的使用)
>
> 1. Berkeley UNIX操作系统定义的 Socekt Interface. -- socket
> 2. Micorsoft在其基础上实现了 Windows Socket Interface -- WINSOCKET



## Socket

### 概述

最初，socket仅仅是面向UNIX和TCP/IP协议栈的接口。

目前，socket已经成为事实上的工业标准，且被绝大多数OS支持。



它是Internet网络应用最典型的API接口。

<font color="red">基于CS架构，为应用进程间的通信提供了一种抽象机制。</font> 

![image-20211017164420225](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017164420.png)

> Client进程这个插头，插到Server进程这个插座上，于是两者就建立起逻辑通信。
>
> 所以，从表面上来看，socket绑定了两个进程，并实现进程间通信。



###  Socket的匹配机制

那么Socket是如何匹配的呢？(客户端进程应该与哪一个服务器进程通信？？)

![image-20211017164819834](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017164819.png)

显然单单使用IP是无法区分不同的进程的		

![image-20211017165147547](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017165147.png)



事实上，应用层是通过传输层协议来实现socket的。

为了区分我们引入了端口

![image-20211017174008166](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017174008.png)

于是通过ip+port可以对外确定一个socket连接。

> socket是使用传输层服务的一种方式。
>
> socket保存了进程间逻辑连接的必要信息。
>
> 应用程序创建socket后，就可以通过socket中的目标ip+port让传输层传输信息。
>
> 同样服务器，发送回信息后，传输层通过网络层拿到报文后，通过socket将报文发送给对应的进程。

---

### Socket抽象

操作系统是如何管理应用程序创建的socket呢？

应用创建socket后会返回一个整数<font color="red">socket descriptor</font>,即套接字描述符。

操作系统通过socket descriptor来引用socket对象。

’

操作系统会将socket进行抽象，然后管理，这就是socket抽象

![image-20211017175939034](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017175939.png)



### Socket数据结构(了解)

![image-20211017180135883](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017180135.png)



---

> 后面就将Socket编程的API函数了，这个我去看java socket的编程就好了。

---

# 传输层(上)

## 传输层服务

### 传输层作用



传输层的作用：<font color="blue">传输层协议为运行在不同Host上的进程提供了一种<font color="red">逻辑通信机制。</font></font>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017154106.png" alt="image-20211017154105559" style="zoom:50%;" align="left"/>



### 分层模型中的作用

端系统运行传输层协议

- <font color="red">发送方</font>：将应用递交的消息分成一个或多个Segment,并向下传给网络层
- <font color="red">接收方</font>：将接收到的Segment组装成消息，并向上交给应用层。

> Segment -- 报文段





### 传输层VS网络层

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017154322.png" alt="image-20211017154322503" style="zoom:50%;" align="left" />

---



### 传输层协议

#### TCP

TCP提供<font color="red">可靠的</font>，<font color="red">按序的</font>交付服务。

> 可靠指在传输过程中：报文不会出错，丢失；
>
> 按序是指在接受报文时的顺序就是发送报文的顺序。

为了实现这两个目标TCP需要

- 拥塞控制
- 流量控制
- 连接建立

---

#### UDP

UDP不可靠的交付服务，基于<font color="red">”Best-effort“</font>的网络层，没有做扩展。

> UDP仅仅实现了传输层必要的服务 -- 多路复/分用

---

以上两种服务均不提供<font color="red">延迟</font>和<font color="red">带宽</font>的保证。

---



> 以上两节属于同一节课内容：TCP概述。
>
> 主要讲了传输层的作用以及在分层模型中扮演的角色，还补充了传输层与网络层的区别；
>
> 最后讲了TCP与UDP的特点。

---

## 多路复用与多路分解

### 为啥需要

![image-20211017160848492](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017160848.png)



<font color="red">因为传输层协议会对应多个application实体--socket 。</font>



> socket是应用层与传输层交互的中间对象。



---

### 分用原理

第一步

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017192804.png" alt="image-20211017192804313" style="zoom:50%;" align="left"/>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017192929.png" alt="image-20211017192929323" style="zoom:33%;" align="left"/>



> 在分层模型的数据传输中，发送端不断加数据，接收端不断减数据。
>
> ![image-20211017192505352](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017192505.png)



第二步

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017192845.png" alt="image-20211017192845337" style="zoom:50%;" align="left"/>

---

### 无连接分用

UDP的Socket用二元组表示目的IP+Port，显然没有源IP+port是无法建立连接的。



假设，主机IP记为IPA,通过99111端口创建一个socket

```c++
DatagrameSocket mySocket1 = new DatagrameSocket(99111)
```

那么当主机接收到UPD段后，会检查段中的目的端口号，然后将UDP段导向绑定在该端口号的socket

这样会出现的结果是：<font color="blue">来自不同源的IP数据报都会导向同一个socket</font>

 

如下图所示

![image-20211017194455686](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017194455.png)

> 在返回信息时，会swap(sp,dp)。

---

### 面向连接的分用

TCP的socket用四元组表示：源IP+port，目的IP+port;

接收端利用所有的四个值将Segment导向对应的Socket.

实际上之前的UPD的socket只有一个：*服务器IP+服务器进程port*

但是在TCP的连接中，<font color="blue">每个不同客户端(客户端IP+port)都会被分配一个socket.</font>



![image-20211017195435930](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017195436.png)



> TCP是面向连接的协议，即一对一的协议。
>
> P1,P3的连接由于四元组中的S-IP不同被导向不同的Socket，虽然他们的端口号相同，但是S-IP不同说明是在两台主机上(不在同一个命名空间内)，所以是可以重复的。

---

多线程web服务器: 让线程与socket绑定。

![image-20211017200106184](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211017200106.png)

---

## UDP

- user datagram protocol

### UPD机制和缺点

仅仅在IP协议上增加了

1. 复用，分用
2. 简单的错误校验机制
   1. 不能保证底层一定实现了错误校验功能。
   2. 即使链路层实现了错误校验，也不能保证网络成路由器转发时不出错。

---

这样的UPD只能提供一种”<font color="red">Best-effort</font>“服务，可能丢失；



<font color="blue">UDP是无连接的，发送方和接收方直接不需要握手</font>，

所以<font color="red">每个报文段的处理独立于其他段</font>。



---

### UDP的优势和应用

总的来说UPD很不好，那么为什么UDP还是存在呢？

那是因为UDP有一些优势。

1. 无需建立连接，使得延迟很短。
2. 实现简单，无需维护连接状态。
3. 头部开销小
4. 没有拥塞控制：应用可以更好的控制发送时间和速率。



常用于流媒体

- 容忍丢失
- 速率敏感

还有DNS，SNMP

---

那么如何在UDP上实现可靠数据传输？

- 在应用层增加可靠性机制。
- 应用特定的错误恢复机制。



---

### 	UPD报文格式

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018135924.png" alt="image-20211018135924717" style="zoom:33%;" align="left"/>



### UDP校验和

反正原理就是，发送方与接收方比对同一个算法的结果是否相同，不同就说明传输的过程中出错了。

![image-20211018140635833](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018140635.png)

> 我觉的没必要记怎么算。	
>
> 不过要知道一点，就是这个算法没有检测出错误，不意味着内容就一定没错。
>
> 这种情况就超出该算法的检测范围了。



每次读取两个16-bit整数，如果有进位，就sum++ (java中的char是16位整数,int 32位)

```java
// 初始化校验和
char sum = 0;
int checkSum = 0;
char maxChar = 0xFFFF;

// 循环读取char整数

while (char c = nextChar()){
	checkSum += c; // 累加
	
	if (checkSum > maxChar) //也就是最高位溢出了
        checkSum++; // 自增
    	~checkSum;  // 按位取反
}
```

​	

---

## 可靠数据传输原理

### 可靠传输协议模型

#### RDT模型概述

什么是可靠 ： <font color="blue">不错，不丢，不乱。</font>

为此我们需要定义<font color="red">可靠数据传输协议 </font>

但是<font color="blue">信道的不可靠特性决定了可靠数据传输(RDT)协议的复杂性</font>

> RDT 可靠数据传输  UDT不可靠数据传输

![image-20211018154214005](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018154214.png)

> 我们实际是在UDT信道上通过RDT协议实现RDT信道



#### RDT协议接口

![image-20211018154610932](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018154611.png)

> 注意 rdt_send()只需要被调用一次，然后就完全交给TCP了。
>
> 同样 deliver_data()也只是返回处理好的，中间不论是出错还是什么应用层都不知道。
>
> 但是，udt_send(),rdt_rev()都是双向箭头，说明在不可靠的信道上实现可靠数据传输需要双向控制消息流动。



---

### 实现思路

1. <font color="red">渐进的</font>去设计可靠数据传输协议的发送方和接收方

2. 设计过程中<font color="blue">只考虑单向数据流动</font>
   1. <font color="red">控制信息是双向流动的。</font>

3. 使用<font color="red">状态机(Finite State Machine FSM)</font>描述协议。

![image-20211018155835341](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018155835.png)

> 圆圈表示状态，箭头标识状态变化。 箭头上标注 event/action信息



下面我们就逐步去实现这个模型。



---

### RDT1.0:可靠信道

首先，假设底层信道<font color="blue">完全可靠</font>(最简单的模型，渐进的第一步)

- 不会发生错误（bit error）
- 不会丢弃分组



在这种可靠信道中，传输层是不需要控制信息的，因为完全可靠。

也就是说两者的<font color="red">FSM是独立的</font>不会发生信息交换。



FSM如下：

![image-20211018161221772](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018161222.png)

> sender一直等待上层调用rdt_send(data)。一旦调用，直接将data分组得到的packet使用upd_send(packet);
>
> receiver一直等待网络层的调用。一旦调用rdt_rev()，将拿到的packet提取为data，通过deliver_data()传输到上层。

---

### RDT2.0：产生位错误

1. 可能会出现0反转为1，1反转为0的问题。
2. 分组不丢，不乱



#### 校验packet是否发生bit error

首先，receiver需要知道收到的packet有没有产生bit error。

显然，用之前学的<font color="red">check sum</font>去检验。



#### 错误恢复机制

那么，现在的主要问题就是如何从错误中恢复？

显然我们需要设计一种消息机制，让receiver告知send是否正确接收到了packet 。



由此出现了一种确认(Acknowledgements)机制

- `ACK`:接收方显示的告知发送方分组已<font color="blue">正确</font>接收
- `NAK`*<u>(Negative Acknowledgements)</u>*:接收方显示告诉发送方分组有<font color="blue">错误</font>
- 发送方接收到`NAK`后，<font color="blue">重传</font>分组



基于这种重传机制的rdt协议称为<font color="blue">ARQ(Automatic repeat reQuest)协议</font>





#### FSM描述

![image-20211018170842801](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018170843.png)

> 只是状态转化，不需要其他操作就使用`^` 表示 `no action`. 
>
> `sndkpt` sender的包，`revpkt` receiver的包。
>
> `corrupt(rcvpkt)`校验接收到的包是否存在bit error(被破坏)

> **sender**
>
> 在RDT1.o1的基础上，udt_send()之后，sender的状态是`wait for ACK or NAK`;
>
> 如果返回值是ACK就回到之前的状态，如果是NAK需要重发，然后继续等待。

> **receiver**
>
> 接收到`rcvpkt`
>
> ​	if (`corrupt`){
>
> ​		`udp_send`(`NAK`);	
>
> ​	}else{
>
> ​		extract(`rcvpkt`,`data`);// 抽取data
>
> ​		deliver_data(data);// 返回给上层
>
> ​		`udp_send`(`ACK`);	
>
> ​	}

---

### RDT2.1:应对ACK破坏

RDT2.0的实现依赖于ACK反馈机制，但是如果<font color="red">包含ACK/NAK信息的包被corrupt怎么办</font>？



有以下下解决的思路

1. 为ACK/NAK添加校验和，检测并<font color="blue">纠错</font>。
   1. 算法难以实现纠错
2. 添加额外的控制消息：告知receiver，ACK/NAK被破坏了
   1. 治标不治本，如果这个控制消息也被破坏了怎么办？
3. 如果ACK/NAK坏掉，sender重传
   1. 不能简单重传，可能产生<font color="blue">重复分组</font>。



我们一般使用思路3，不过需要引入新的机制处理重复分组的问题。	

<font color="blue">解决重复分组问题的思路</font>

- 给每个分组<font color="red">添加序列号(Sequence Number)</font>:发送方给每个分组编号
- 接收方丢弃重复分组

---

#### 发送方FSM

![image-20211018180439766](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018180439.png)

> 在制作分组的时候需要加入序列号。
>
> 如果收到`NAK`,或者确认消息坏了，就重发。
>
> 直到收到`ACK`,修改序列号，继续发送。





#### 接收方FSM

![image-20211018181134672](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018181134.png)

> 接收方按顺序接受packet，如果在希望收到seq0的时候，实际收到的是seq1 
>
> 这个时候如何处理
>
> 1. 返回NAK，那么sender会不断将这个seq发送给你。
> 2. 忽略，那么sender将一直出于忙等待
> 3. 只能返回ACK

 

#### 编号0，1？

至此，我还有一个问题为什么状态机的seq只需要0，1就可以了？

这和<u>*停-等协议*</u>有什么关系？

> sequence number的作用是防止分组重复，分组重复的原因是当sender发现ACK/NAK corrupt时，需要重发。
>
> 
>
> 如果sender不会等待receiver的回复，而是不停的发送packet，那么为了同时管理多个pkt，显然需要n个sequence number.
>
> stop-wait模型不会出现同时发送多个packet的情况
>
> 
>
> 那么使用停等协议就只需要两个编号吗？
>
> ![image-20211018200348318](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018200348.png)
>
> 
>
> 确实只需要两个，也必须有这两个编号0,1;
>
> - 所有情况如下，会产生***重复packet***的就是黄色部分.
>
> - 这个时候receiver已经有了req0，此时的状态是需要req1,sender收到的是corrupt(ACK)重新发送req0.
>
> - receiver返回ACK的目的是告诉sender发送下一个
> - 所以sender的状态 0 -> 1 表示之前的已经发送完成，实际上1 -> o也是一样
> - 总之，通过0,1两个状态之间的切换表示发送当前pkg与下一个pkg的状态切换
>
> 



所以简单的回答是0,1编号表示两个状态，一个是<font color="blue">发送(接受)当前packet</font>，另一个是<font color="blue">发送(接受)下一个packet</font>。

当receiver接收到req1时，receiver的状态变成wait for req1;

这时如果没有1这个状态，sender发送的seq0就会重复。

但是也只需要一个1，而不需要2，3，4；

---

### RDT2.2:无NAK消息协议

![image-20211018201732169](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018201732.png)

> receiver返回的是ack表示接收到了packet。携带的编号表示当前接收到的最新的pkt的编号。

![image-20211018201933540](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018201933.png)

> 不用看状态图，只要记住sender接收到重复的ACK后，重传即可。

---

### RDT3.0

#### 定时器机制

假设信道会丢失分组。

<font color="blue">校验和+序列号+ACK+重传</font>还够用吗？？



显然不够，比如 sender发送了req0，结果在到达之前丢失了。

receiver一直没收到所以不会发送ACK，sender没有收到receiver的ACK所以会一直等待。

最终结果就是两个进程永远都在等待"到达不了的ACK".

或者，接收方收到packet，但是返回的ACK丢失了，也会一直等下去。



怎么处理这个问题呢？？？

很简单，让sender等待<font color="red">"合理"</font>的时间，如果没收到ACK就<font color="blue">重传</font>。

- 但是可能的情况是，没丢包，只是延迟较长.	
- 这会导致重复的问题 -- 可以通过序列号的机制解决

为此我们引入一个<font color="red">定时器</font>

![image-20211018203859251](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018203859.png)

---

#### 场景分析	

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018205039.png" alt="image-20211018205039745" style="zoom:100%;" align="left"/>

> 不丢失肯定是没有问题的



![image-20211018205033191](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018205033.png)

> 在这种模型下，丢失的是pkt还是返回的ack都一样，反正都是由receiver重发。
>
> 重复的pkt直接丢掉。



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018205429.png" alt="image-20211018205429142" style="zoom: 67%;" align="left"/>

> 如果定时器设置的时间太短，会有一个ACK1姗姗来迟。
>
> 这时存在一个问题与原子性操作有关，就是上一个操作中的ACK1插到了本该是这一次操作的ACK0之前。
>
> 那么render会以为pkt0发送失败了，而去重发pkt0。
>
> 而原来的ACK0就变成了pkt0的返回值。
>
> 再往后整个状态机就会乱掉。(因为不确定谁的ACK会先到)

好像不会出错？？	



---

#### 性能分析

![image-20211018211209332](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211018211209.png)

> 性能差的原因是每一次都需要等待分组到达，返回ACK，需要一个	RTT(round trip time).
>
> 也就是说基于*停-等协议*这种设计不适用于传输过小的的数据包。	
>
> 每次传输分组只需要 10^-8s,但是由于延迟需要额外等待0.3s



所以我们需要一定保证协议合理与物理资源相匹配。 -- <font color="blue">软硬件的协同设计</font>	

----

## 滑动窗口协议

### 流水线协议(pipeline)

我们可以通过<font color="blue">流水线机制,提高资源利用率。</font>

![image-20211019073349563](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211019073349.png)



为了实现流水线机制

允许发送方在收到ACK之前连续发送多个分组

- 需要更大的<font color="red">序列号范围</font>
- 发送方和接收方需要更大的存储空间以<font color="red">缓存分组</font>



实现效果如下：

![image-20211019074106989](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211019074107.png)

> 之前是*停-等协议*，现在何种就是*流水线协议*。

---

### 滑动窗口协议

- 流水线协议的具体实现

![image-20211019074752152](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211019074752.png)

> 绿色表示已经发送并确认的分组。
>
> 黄色表示已经发送，但是还没确认。
>
> 蓝色表示还可以发送的分组。



### GBN和RS

具体内容在ipad上，没整理。



---

# 传输层(下)

## 面向连接传输协议

###  TCP概述

#### TCP特点(废话，相当于总结)

> 点对点：一个发送方，一个接收方。
>
> 可靠的，按序字节流
>
> 流水线机制
>
> - 基于拥塞控制和流量控制机制动态设置窗口尺寸
>
> 送方/接收方缓存（既有点像GBN，不过更像SR）
>
> 全双工：同一连接中可以传输双向数据流。
>
> 面向连接：
>
> - 通信双方在发送数据之前必须建立连接
>
> - 连接状态只在连接的两端维护，在沿途节点中并不维护状态。
>
> TCP连接包括：两台主机上的缓存，连接状态变量，socket等。 

---

#### TCP段结构(重点，下面都会用到)


![img](https://cdn.nlark.com/yuque/0/2021/png/574020/1634623210233-d8bf512f-01d0-4db8-92a0-b8919d8a2468.png)

> 里面有好多东西，后面应该都会用到。 

##### Sequence number和acknowledgement number

<font color="blue">sequence number</font>

- 指的是当前segment的第一个字节的编号

- 建立TCP连接时双方 随机选择序列号（这是什么意思？？）

> TCP 是面向字节流的协议，通过TCP传输的字节流的每个字节都会分配序列号.
>
> sequence numner是本报文段(segment)第一个字节的序列号



<font color="blue">acknowledgement number</font>

- 希望接收到的下一个字节的序列号

- 使用累积确认：该序列号之前的字节均已被正确接收到



Q：接受放如何处理乱序到达的segment？

A：TCP规范中没有规定，由TCP的实现者做出决策



> 在建立tcp连接时，连接双方都会将自己的初始化序列号isn发给对方，用来标识本端发送数据的起始编号。
>
> 
>
> ack编号一般表明：
>
> 1. 本端需要接收的下一个数据包的起始编号（也可以说需要接收的下一个字节的编号）。
>
> 2. 对端发送的“编号在ack之前（对端isn～ack-1之间）的数据”本端都已经确认接收。
>
> 



建立连接后的TCP的简单数据交换，就如下

![img](https://cdn.nlark.com/yuque/0/2021/png/574020/1634625344574-cf207f93-47e8-43c8-8c3f-6eed2d3f89fd.png)

---

### TCP可靠数据传输(超级重点)



基本实现思路

- 使用流水线机制
- 使用累积确认
- 单一重传定时器
- 触法重传的事件
  - timeout
  - *(重复ACK)，暂不考虑*

暂不考虑

- 重复ACK
- 流量控制

- 拥塞控制



#### 设置timeout(了解大概思路)

##### 预估RTT

首先，需要计算`EstimatedRTT`。

![img](https://cdn.nlark.com/yuque/0/2021/png/574020/1634626481113-a5162aee-7412-437c-b4e3-48089226193b.png)

> `EstimatedRTT`使用加权的方式，同时考虑到当前测试的时间与平均时间，实现动态变化。

---

##### 计算安全边界

有了Established RTT之后还需要考虑timeout时长应该比RTT长多少？

也就是<font color="blue">安全边界</font>应该有多大,如果Established RTT波动较大，安全边界就会比较大。



![img](https://cdn.nlark.com/yuque/0/2021/png/574020/1634776920656-c82f25ef-3611-4ea7-93c6-52e58c3af389.png)



> 总结一下
>
> 1. 超时时间需要考虑两个因素
>    1. 预估RTT:`EstimatedRTT`
>    2. 安全边界`DevRTT`
>    3. `TimeoutInterval = EstimatedRTT + 4*DevRTT`
> 2. `EstimatedRTT`：需要考虑到之前的 `EstimatedRTT`
> 3. `DevRTT`是 `SampleRTT`与`EstimatedRTT`的差值

---

#### TCP发送端

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022155750.png" alt="image-20211022155750143" style="zoom:100%;" align="left"/>

> 这里的sequence number 和Ack number是新引入的，之前的模型实际上传的是packet,标号也是pkt的编号。
>
> ACK返回的一直都是



下面看一下TCP重传的场景

![image-20211022163730808](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022163730.png)

![image-20211022163801736](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022163801.png)



![image-20211022163812421](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022163812.png)

#### TCP接收端

ACK生成的一些细节。

第一种情况：segment按序到达，接收端会有一个延迟返回ACK的操作。

![image-20211022164242313](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022164242.png)

第二种情况：在500ms内到了一个新的按序的segment，立刻发送新的ACK,确认两个端。

![image-20211022165053572](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022165053.png)

第三种情况：乱序的segment到达后，立刻发送ACK告诉sender你期望收到的segnent

(也就是说，乱序到达的ACK被之间丢弃了？？)

![image-20211022165312609](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022165312.png)

---

#### 快速重传机制

TCP的timer和GBN基本是一样的，每次收到一个ACK，timer就重置.

这个timer只能限制ACK序列的返回间隔。而不能用于要求某一个具体的ACK的返回时间。

假设 sender发送 N-1,N+1,N+2,N+3..也就是N丢失了，那么的N丢失不一定会引发timeout,只要N+1,N+2的ACK在timout之前返回。



而GBN模型中的receiver遇到乱序的segment就丢弃了不会有ACK饭返回，所以只要N丢了，剩下的也不会返回ACK所以重传的时间间隔就只是一个RTT.

而TCP由于乱序的seg会缓存并返回ack所以，重传时间可能会被无限刷新。





##### 原理

如果某个分组n丢失，那么该分组n之后到达的都是乱序segment，receiver会不断发送ack(n)；

sender在接收到3个以上重复的ack后就可以假定该分组以及丢失了，在超时之前就直接重传该分组。



##### 修改发送端

![image-20211022170432427](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022170432.png)



##### 为什么是3？？

下面AB发送4个segment(没有4个seg压根就不会有3次乱序)。

当发生3重复ACK有50%概率乱序，50%概率丢包。

所以这个时候就可以直接重发了。

> **两次duplicated ACK肯定是乱序造成的！**
> **丢包肯定会造成三次duplicated ACK!**
>
> 假定通信双方如下，A发送4个TCP Segment 给B，编号如下，N-1成功到达，因为A收到B的ACK(N)，其它按照到达顺序，分别收到ACK(N)的数目：
>
> A ---------> B
>
> 
>
> **A方发送顺序**N-1，N，N+1，N+2
>
> **B方到达顺序**
>
> N-1，N，N+1，N+2
> A收到1个ACK (N)
>
> N-1，N，N+2，N+1
> A收到1个ACK (N)
>
> N-1，N+1，N，N+2
> A收到2个ACK (N)
>
> **N-1，N+1，N+2，N**
> **A收到****3个ACK (N)
> **
> N-1，N+2，N，N+1
> A收到2个ACK (N)
>
> **N-1，N+2，N+1，N**
> **A收到****3个ACK (N)**
>
> 
>
> **如果N丢了，没有到达B**
>
> **N-1，N+1，N+2**
> **A收到3个ACK (N)
>
> N-1，N+2，N+1**
> **A收到****3个ACK (N)**
>
> 
>
> TCP segment 乱序 有2/5 = **40% 的概率**会造成A收到三次 duplicated ACK(N);
>
> 而如果N丢了，则会**100%概率**A会收到三次duplicated ACK(N);
>
> <font color="red">基于以上的统计，当A接收到三次 duplicated ACK(N)启动 Fast Retransmit 算法是合理的，即立马retransmit N，可以起到Fast Recovery的功效，快速修复一个丢包对TCP管道的恶劣影响。</font>
>
> 而如果A接收到二次 duplicated ACK(N)，则一定说明是乱序造成的，即然是乱序，说明 数据都到达了B，B的TCP负责重新排序而已，没有必要A再来启动Fast Retransmit算法。

---

#### TCP&&GBN&&SR

> TCP是GBN协议和SR协议的混合体
>
> - TCP发送方仅需要维持已发送过但未被确认的最小序号和下一个要发送的字节的序号就可以了，这一点和GBN一致。
> - SR协议用的是窗口长度N来限制流水线中未完成的、未被确认的分组，这样导致窗口的长度的N不好控制。
> - GBN定时器过期之后发送方会重传未被确认的最小序号之后的数据段，这样很可能会造成重发大量分组，导致占用带宽，分组冗余。TCP就和SR相似，用的是选择重发，只发未被确认的最小序号的分组。
>
> 
>
> - **重传**   对于丢失分组 n，在GBN中，发送方会重传n及n以后的数据包；在SR中，只会重传n。
>
>   **缓存**   对于乱序达到的分组，在GBN中，接受段端会直接丢弃；在SR中，会把它们缓存下来。
>
>   **定时器** 在GBN中一个连接只会设置一个定时器，在SR中会为每个分组设置定时器。
>
>   而TCP呢？
>
>   重传和缓存像SR，定时器像GBN。



TCP使用 cumulative ACK的好处是：sender 只需要维护 send_base即当前最大ACK返回值。

而不需要想SR一样维护一个消息窗口‘



如果N丢包 N+1，N+2，N+3...会被receiver缓存，然后通过快速重传机制N会被重发过来。

这时TCP接收端会将ACK(N)直接返回(情况一),然后如果来了一个N+4(情况2)延迟发送ACK(N+4);

假设这个时候没有新的segment，send_base就更新为N+4



只是用一个timer的缺点也被快速重传机制纠正了。



TCP通过重复ACK让sender只需要发送重复ack的segment不需要像GBN全都重传。 



---

### TCP流量控制

- 就是限制发送方的传输速度

![image-20211022180907610](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022180907.png)

​	

简单计算公式与实现方式--RcvWindow

![image-20211022181132737](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022181132.png)

> RcvWindow剩余缓存，RcvWindow总缓存。
>
> 如果receiver告诉sender没有剩余空间了，那么当app处理掉部分数据后，receiver该怎么告知receiver？？
>
> 显然receiver是不能主动反馈的，所以即使RcvWindow=0,sender仍可以发送一个很小的段用于捎回RcvWindow的信息。

---

### TCP连接管理

TCP sender和receiver在传输数据之前需要建立连接.



建立连接的时候需要初始化TCP变量

1. 交换Sequence number
2. 建立buffer,以及流量控制信息。



Client创建连接socket

```java
Socket clientSocket = new Socket("hostname","port number");
```

Server则是等待客户的连接请求

```
Socket connectionSocet = welcomeSocket.accept();
```



#### 三次握手

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022182546.png" alt="image-20211022182546085" style="zoom:80%;" align="left"/>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022183027.png" alt="image-20211022183027710" style="zoom:50%;" align="left"/>

> 如果server如果在一段时间内没有收到ack，就会回收已经分配的资源。
>
> --------------------------------------------------------------------------------------------
>
> SYN 泛洪是一种 TCP 拒绝服务攻击，在这种攻击中一个---或多个恶意的客户端产生一系列 TCP 连接尝试( SYN 报文段)，并将它们发送给一台服务器，它们通常采用 "伪造" 的源 IP 地址。服务器会为每一条 TCP 连接分配一定数量的连接资源。由于连接尚未完全建立，服务器为了维护大量的半打开连接会在耗尽自身内存后拒绝为后续的合法连接请求服务。

> 我们首先要知道到一点就是， TCP 的可靠连接是靠 seq（ sequence numbers 序列号）来达成的。
>
> TCP 设计中一个基本设定就是，通过TCP 连接发送的每一个包，都有一个sequence number。而因为每个包都是有序列号的，所以都能被确认收到这些包。
>
> 确认机制是累计的，所以一个对sequence number X 的确认，意味着 X 序列号之前(不包括 X) 包都是被确认接收到的。
>
> 
>
> <font color="blue">TCP 协议是不限制一个特定的连接（两端 socket 一样）被重复使用的。</font>
>
> 所以这样就有一个问题：<font color="red">这条连接突然断开重连后，TCP 怎么样识别之前旧链接重发的包？</font>——这就需要独一无二的<font color="red"> ISN（初始序列号）机制。</font>
>
> 
>
> 我们可以认为 ISN 会是唯一的
>
> 
>
> 发送方与接收方都会有自己的 ISN （下面的例子中就是 X 与 Y）来做双方互发通信，具体的描述如下：
>
> syn声明自己的isn，ack回复syn
>
> ```
> 1) A SYN B : my initial sequence number is X 
> 2) B ACK A : i konw your sequence number is X,and i except your next seqNum = X+1;
> 3) B SYN A : my initial sequence number is Y
> 4) A ACK B : i knoe your sequence number is Y,,and i except your next seqNum = Y+1;
> ```
>
> 所以三次握手实际是四次握手，2，3合成SYN+ACK段。
>
> 
>
> 因此三次握手是必须的，因为必须通过至少3次交换信息才能确保双方知道彼此的isn.
>
> 
>
> 简单归纳来说就是因为没有网络全局时钟，两台机器分别为了确认序号，证明这个包是新的，而不是在链路中delay的



---

#### 四次分手

![image-20211022183931830](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022183932.png)



#### TCP连接的生命周期

##### Client

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022191356.png" alt="image-20211022191356211" style="zoom:67%;" align="left"/>

> 等待30s的目的是防止ack丢失了，server重发fin。

---

##### Server



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022191718.png" alt="image-20211022191718232" style="zoom:67%;" />

   

---

## 拥塞控制

### 拥塞

非正式定义：<font color="blue">太多发送主机发送了太多数据或者发送数据太快，以至于网络无法处理，</font>

表现：

- 分组丢失(路由器缓存溢出)
- 分组延迟过大(在路由器缓存中排队)

### 拥塞成因和代价

![image-20211022210527812](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022210528.png)

> 两个sender的传输速率相同，由于路由器的缓存是无限的，因此不会丢包。



> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20210312195233.png" alt="image-20210312195233265" style="zoom:67%;" align="left" />



在这个理想模型中，我们看到拥塞带来的第一个问题：分组时延变大。

---

![image-20211022211559367](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022211559.png)



假设链路带宽是R，那么每一台主机的上传速率小于R/2.



![image-20211022213116405](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022213116.png)

> 我的困惑就是，反正就像食堂打饭一样，能服务多少学生取决于大妈的效率。后面拍着也是排着(只要你不觉得满，也就是时延确实变大了，不如错开高峰期)，但是有效吞吐量应该是一样的啊。除非有重复的学生排队，就是重传但是分组实际上没有丢失，

> 如果一个线路同时服务两个路由器，其中一个路由器阻塞，一个空闲，那么阻塞的路由器的包不断被丢弃，而线路却不断运输要被丢弃的包；
>
> 如果带宽全部用来运输到另一个空闲路由器的包带宽就没有浪费。

> 也就说注定要被丢弃的分组占据了有限的带宽，使得有效带宽变小。
>
> 这和我之前食堂打饭的区别就是这里的瓶颈不仅仅是打饭的阿姨，排队本身也是一种资源，排队你可以去别的大妈哪里打饭。





![image-20211022222004476](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211022222005.png)

> 这里说的好像就是我上面说的，注定要被丢弃的分组占有了部分带宽，这带宽属于无效带宽。

当网络瘫痪，所有的带宽都用于发送前往阻塞的路由器的分组。



---

### 拥塞控制原理

> 已清楚拥塞控制的必要性，但其他网络层级不一定实现了可靠的拥塞控制，所以在传输层自行实现。

#### 实现方案

> 拥塞控制的朴素思想就是控制网络负载，控制的方式有以下两种。

##### 1.端到端拥塞控制

网络层不向端系统提供显式拥塞信息，由端系统自行判断并解决。TCP采用此方案。

##### 2.网络辅助拥塞控制

网络层向端系统提供显式拥塞信息。具体有两种

- 直接向发送方反馈网络信息。
- 网络层标记出现拥塞的分组，接收方接收到通知发送方。

> 这两种的区别就在于网络层是否显示的反馈网络拥塞信息。



#### ATM拥塞控制

我直接跳过。







## TCP拥塞控制原理(重点)



### 如何限制发送速率？

sender通过congWin限制发送速率rate。（将滑动窗口的大小设置为congWin）

1. congWin = lastByteSend - lastByteAck （正在发送的数据）
2. rate = congWin/RTT



congWin随着网络的拥塞情况动态变化，进而动态限制发送速率。

如果网络拥塞严重，就缩小窗口；反之，则扩大窗口。



紧随而来的问题是：

### 如何感知网络的拥塞？



我们定义一个loss事件，事件触发条件为

1. timeout
2. 3个重复ACK 



这样当loss事件发生，我们就降低发送速率。



那么该降低多少？这就引出了下一个问题 ：



### 如何合理地调整发送速率？

- TCP使用AIMD和SS来调整发送速率。



#### AIMD

原理：逐渐增加发送速率，谨慎探测可用宽带，直到发生loss

方法：加性增，乘性减 

- Additive Increase: 每个RTT将CongWin增加一个MSS -- 拥塞避免
- Multiplicative Decrease ：发生loss后将CongWin减半  

MSS max segment size 最大段长



AIMD的速率图 

![img](https://cdn.nlark.com/yuque/0/2021/png/574020/1635166513148-6d40aabe-e346-4db9-bdea-8762617ffe03.png)

#### SS：慢启动



在TCP连接建立时，CongWin = 1MSS。

可用带宽可能远远高于初始速率，因此我们希望CongWin可以快速增长。



原理：当连接开始时CongWin以指数增长。

- 指数性增长：每个RTT将CongWin翻倍，收到ACK进行操作。

![img](https://cdn.nlark.com/yuque/0/2021/png/574020/1635213924826-5d0558c9-f6db-4bae-bf84-5f28370d50cc.png)

------

#### 处理loss事件

- 重复ACK：CongWin减半

- Timeout：CongWin直接设为1MSS



那么什么时候CongWin由快速增长变为拥塞避免？



我们引入一个新的变量Threshold

-  `Threshold = CongWinWhenLoss / 2`

- 当CongWin快速增长到Threshold时就很可能发生loss。



结合之前的AIMD+SS，TCP的速率变化图如下：

![img](https://cdn.nlark.com/yuque/0/2021/png/574020/1635167155227-259f5174-f24c-46aa-ae34-e507782fad65.png)

> 开始 CongWin = 1（A），然后以指数形式快速增长到Threshold（B），然后以线形增长到发生loss（C）。
>
> 发生loss后C，如果是timeout引起，会直接掉到E。从1重新开始，快速增长到ThresholdD，然后再线形增长。
>
> 如果是由于重复ack引起，我们直接从D开始线形增长。

> 注：每次发生loss后会更新Threshold。

------



### 总结：TCP拥塞控制算法

![img](https://cdn.nlark.com/yuque/0/2021/png/574020/1635215225235-f7c2e04c-d829-4498-8322-8132f834fa3c.png)

> SS每个ACK返回，CongWin++, 一轮ACK全返回后，CongWin翻倍。
>
> AI每轮ACK返回，CongWin++。





![img](https://cdn.nlark.com/yuque/0/2021/png/574020/1635215057064-3f9417c6-2c82-4a10-a45a-89e8faf1e325.png)

> 别忘了，Threshold后是线性增长。



----

# 网络层(上)



## 网络层服务

网络层做的事情如下：

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026120610.png" alt="image-20211026120610574" style="zoom:100%;" align="left" />



### 网络层核心功能(超级重要)

#### 转发

<font color="red">什么是转发？</font>

- <font color="blue">将分组从路由器的输入端口转移到合适的输出端口。</font>

<font color="red">如何实现转发？</font>

- <font color="blue">根据转发表确定在本路由器如何转发分组。</font>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026121140.png" alt="image-20211026121140580" style="zoom: 80%;" align="left"/>



#### 路由

<font color="red">什么是路由？</font>

- <font color="blue">确定分组从源到目的经过的路径</font>

使用<font color="red">路由算法</font>确定<font color="blue">网络上端到端的路径</font>，并<font color="blue">记录</font>在<font color="red">转发表</font>中。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026121621.png" alt="image-20211026121621175" style="zoom:80%;" align="left"/>

---

#### 连接建立

> ATM，帧中继提供这样的服务。Internet不不提供。

<font color="blue">概念</font>：数据分组在传输之前，两端主机首先需要建立<font color="red">逻辑(虚拟)连接</font>。

- 网络设备：路由器，参与连接的记录·。



<font color="blue">网络层连接与传输层连接对比：</font>

1. 网络层连接：两个主机之间建立连接，<font color="green">路由器等网络设备参与</font>。
2. 传输层连接：两个进程间建立连接，<font color="green">对中间网络设备透明</font>。

### 网络层服务模型(重要)

> 不同的网络层模型，提供的服务是不同的。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026115829.png" alt="image-20211026115829620" style="zoom:80%;" align="left"/>

> Internet提供无连接服务，ATM提供无连接服务。
>
> 两者最基本的区别就是分组是否会有序到达。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026120008.png" alt="image-20211026120008675" style="zoom: 80%;" align="left"/>

> CBR constant byte rate  带宽固定 -- 电路仿真
>
> ABR available byte rate 有多少带宽，上多少速率。类似TCP拥塞控制。

---

## 虚电路与数据报网络

### 虚电路

> 第一节 核心功能 连接建立 --> 服务模型：有/无连接服务 --> 本节的两种典型网络。

注意！！！<font color="red">虚电路</font> 与<font color="red">数据报网络</font> 都是<font color="blue">分组交换网络</font> 。

- <font color="red">虚电路网络</font>提供<font color="blue">连接服务</font>。

- <font color="red">数据包网络</font>提供<font color="blue">无连接服务</font>。



虚电路

----

#### 什么是虚电路？

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026123806.png" alt="image-20211026123806801" style="zoom:80%;" align="left">

> 本质上是分组交换模拟电路交换。看1.3.1
>
> 电路交换通过多路复用共享带宽，分组交换则是独占所有带宽。



#### 虚电路的实现

![image-20211026124432571](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026124432.png)

> 网络设备维护VC,根据VCID进行转发。



#### 虚电路具体实现 ：vc转发表

![image-20211026125619628](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026125619.png)

> 面临的问题是，不同链路的带宽不同(光纤>>电话线)，导致不同链路可以建立的虚电路的数量是不同的。
>
> 因此就无法保证虚电路上的每一段链路的VCID都相同了。
>
> 
>
> 所以虚电路网络采用局部化管理的思路：同一条虚电路，每一段链路的VCID可能是不一样的。
>
> 虚电路沿途的每一个路由器，利用转发表记录连接关系。

![image-20211026130002013](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026130002.png)

> 虚电路的建立与拆除就对应着VC转发表的维护。
>
> 虚电路建立就增加一条记录；拆除就删除一条记录。

---

#### 虚电路协议

![image-20211026132004577](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026132004.png)

---

所以什么是虚电路？？

就是在VC转发表中记录构成网络中的连通路径。

分组沿着路由维护的路径进行转发。

> 分组会有一个vcid，与路由器的输入VC匹配选择输出接口。
>
> 跳转时更新为输出接口的输出VC.

好处就是先分配后使用，一旦某个链路的负载不够，那么就无法建立虚电路。也就不会出现拥塞了。

---

### 数据报网络

> 由于网络层无连接，分组必须携带目的地址。路由器根据转发表转发分组。
>
> 每个分组独立选路，由于转发表更新导致选择的路径不同。
>
> ![image-20211026144913274](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026144913.png)



#### 如何实现路由表

##### 直接对应？

自然而然引出的一个问题是：如何建立IP与接口的映射？

ipv4有40多亿个地址，难道路由表需要记住所有ip该怎么走吗？

显然是不可能的。

##### 聚合转发表入口

一个解决办法是<font color="blue">针对某个地址范围</font>，绑定接口。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026145531.png" alt="image-20211026145531277" style="zoom: 50%;" align="left"/>



路由器的转发可能是这样：

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026145647.png" alt="image-20211026145647202" style="zoom:50%;" align="left" />

> 但是这只是一种完美的划分，转发的IP必须是需要连续的。
>
> 在实际网络中，地址的划分不是这么完美。



在聚合转发表匹配的时候可能会产生冲突，遵循以下原则。

##### 最长前缀匹配优先

![image-20211026150643314](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026150643.png)

---

### 虚电路VS数据报网络

![image-20211026151221399](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026151221.png)

> 两者由于服务对象的差异，提供不同类型的网络服务模型。

---

## IPv4协议(超级重要)



Internet运行着一下三种协议。其中最核心的就是IP协议。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026161755.png" alt="image-20211026161755248" style="zoom:67%;" />

---

### 	IP数据报

简单分为首部与数据，首部有固定部分(20字节))与可变部分组成。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026181203.png" alt="image-20211026181203309" style="zoom: 80%;" align="left"/>

> 每行32位，4字节

####  首部数据

##### 首部长度

<font color="blue">首部长度</font>4bit，最大表示15.显然不是字节数，而是行数，所以单位是4字节。

一半首部是没有选项字段的，所以长度是20字节，首部长度就是5

##### 服务类型

<font color="blue">TOS</font>:指示期望获得哪种类型的服务

- 1998年字段改名为 <font color="blue">区分服务</font>
- 只有网络提供 <font color="blue">区分服务(DiffServ)</font>时才使用该字段。
- 一般情况不使用，通常取0.



##### 总长度

16位，表示IP分组的总长度，最大是65535，单位字节。

最小的分组首部是20B(字节)，所以携带的数据最多是65515B.



##### TTL生存时间

- time to live 

- 标识 分组的转发次数。

- 每次被路由器转发，TTL--
  - 如果TTL=0,路由器会丢弃该IP分组。



##### 协议

指示IP分组封装的是哪个协议的数据包

- 6 TCP
- 17 UDP



##### 首部校验和

16位，实现对IP分组头部的差错校验

- 计算校验和时，所有位置为0
- 采用反码算数运算求和，和的反码作为首部校验和字段。
- 发送后的IP分组求校验和与首部校验和求和，如果所有位为1，则正确。

<font color="blue">逐跳计算，逐跳校验。</font>



##### 源/目的地址

分别标识发送分组和接受分组的 主机/路由器的IP地址。



##### 选项字段

![image-20211026183514054](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026183514.png)



----

### IP分片

#### 为什么需要分片

首先需要引入一个概念MTU(最大传输单元)

链路层对于封装的数据包通常是有大小限制的，最大封装的数据量就是MTU。



不同链路上的MTU往往是不同的，这就导致了一个问题：

当一个IP数据包在较大的MTU的链路上传输的时候，它可以封装到一个数据帧里进行传播。

但是经过路由器转发到另一个MTU较小的链路的时候，就可能装不到一个frame中了。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026184530.png" alt="image-20211026184530533" style="zoom: 50%;" align="left"/>



这时就涉及到分片与重组的问题了。

---

#### 分片原理

![image-20211026185036819](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026185036.png)

> 能不能分得看IP数据报头部的标志位，如果不允许分片，分组会被丢弃。
>
> 路由器只负责分，到目的主机再重装。



##### 标识（ID）

![image-20211026185522704](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026185522.png)

作为分组的id，用来排序分组。（不能唯一标识一个分组，需要加上源/目的IP）

ip协议利用一个计数器，每产生一个分组，计数器加1



##### 标志位

![image-20211026185721283](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026185721.png)

> MF = 1，当前是某个分组的分片，并且不是最后一片。



##### 片偏移

一个IP分组分片，相对于原IP分组数据的偏移量。

大白话就是，如果 偏移量 =100，分片从原来分组的100开始。

根据偏移量的大小就可以排序出同一个分组所有分片的顺序。



当MF = 0;

- 如果没有分片，片偏移量 = 0；

- 如果是最后一片，片偏移量 != 0



注意：片偏移量单位是以8B，因为<font color="blue">13位的片偏移需要表示的是16位的IP数据报地址</font> ->`8 = 2^(16-13)`

所以，每一个分片的数据长度一定也是8B的整数倍(不包括头部)，即8B是分片的最小单位。

---

#### IP分片过程

![image-20211026191426656](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026191426.png)

> M-20 -- 减去头部20B，剩下的理论最大数据长度
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026191559.png" alt="image-20211026191559027" style="zoom:50%;" align="left"/> --向下取整8，分片可封装的数据大小必须是8的整数，得到分片大小
>
> 
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026192005.png" alt="image-20211026192005257" style="zoom:50%;" align="left"/> -- 分片大小✖单位 8B
>
> 
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026192137.png" alt="image-20211026192137375" style="zoom:50%;" align="left"/> -- L-20总数据量；L-20/d 向上取整



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026192405.png" alt="image-20211026192404964" style="zoom:50%;" align="left"/>



#### 实例

![image-20211026192727849](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026192727.png)



---

### IP编址

#### 编址对象：网络接口

IP编址的对象实际上是与物理链路相连，实现了网络层功能的<font color="red">接口</font>。



路由器通常有多个接口，

主机通常只有两个接口，有线的以太网接口，无线的802.11接口。



而只实现了链路层功能的，交换机，WiFi接入点都是不需要IP编址的。



#### 编址格式: 32bit串

![image-20211026200334634](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026200334.png)>

> 一般使用点分十进制标识32比特串.



----

#### 分配IP方式: IP子网

现在的问题是<font color="red">如何分配IP?</font>

之前在学习数据报网络的路由表时就提到,<font color="blue">如果随意分配会导致路由表十分复杂.</font>

我们使用<font color="blue">层次化</font>的思想编址



我们将IP的高位抽取出来,作为网络号,同一片区域的设备使用相同的<font color="blue">网络号</font>.

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026201652.png" alt="image-20211026201652638" style="zoom:80%;" align="left"/>

使用相同网络号的设备就构成了一个<font color="blue">IP子网</font>.

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026201644.png" alt="image-20211026201644199" style="zoom:80%;" align="left"/>

##### IP子网特点

IP子网中主机IP具有相同的子网号.

主机具有<font color="red">不跨越路由器</font>(第三层以上的设备)可以彼此<font color="red">物理联通</font>的<font color="blue">接口</font>.



---

##### 子网个数

![image-20211026202130390](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026202130.png)

> 之前讲过子网不会穿越路由器,所以将图中的路由器去除,整个网络被分离为3个独立的子网.



----

### IP地址分类

#### 有类IP地址

> 之前IP编址讲了我们需要划分子网,这一节讲了具体的子网划分方式.

分类的思想就是2分法.

![image-20211026203153285](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026203153.png)

> D,E两类不区分网络号和主机号,因为都用于特殊目的;D:多播;E:保留.



#### 特殊IP地址

![image-20211026203832326](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026203832.png)

> NetID全0
>
> - HostID全0
>   - 表示本网中的自己
>   - 用于:当一个主机还不确定自己的IP,但是还是要利用IP发送分组.
> - HostID特定值
>   - 表示本网特定某个主机.
>
> 255.255.255.255 受限广播地址,在本网内广播.
>
> 
>
> NetID特定值
>
> - HostID全0
>   - 网络号
> - HostID全1
>   - 该子网的广播地址
>
> 127.0.0.1 - 127.0.0.254(hostID只有最后8bit) 回环地址



#### 私有IP地址

从有类中拿出来的,在公网中是无效的IP地址.只能在内部网络使用.

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026205415.png" alt="image-20211026205415460" style="zoom:67%;" align="left"/>



---

### IP子网与子网划分



之前在有类IP地址的划分中存在问题: 不灵活.

A类特别大,网络数很少;c类网络数很多,但是每个网络又很小.

比如一个公司网络又1000台主机,C类地址不够,B类地址又太多了.



而且对于A类网络,单个路由器是无法维护如此大量的主机,必须划分为多个子网.

---

#### 子网划分的原理

借用主机号的高位变成子网号.

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026211157.png" alt="image-20211026211157696" style="zoom:80%;" align="left"/>

划分子网以后,数据报就只会发送到对应的子网的路由器上.



划分完子网后的问题是,原来有类子网的网络号都是定义好的,现在加了一个SubID,



<font color="red">怎么确定是否划分了子网?子网划分了几位?</font>

我们引入子网掩码 



#### 子网掩码

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026211739.png" alt="image-20211026211739144" style="zoom:67%;" align="left"/>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211026211908.png" alt="image-20211026211907621" style="zoom:67%;" align="left"/>

#### 子网掩码的应用

那么路由器如何将IP发送到对应的子网??

<font color="blue">我们将目标IP与子网掩码进行<font color="red">按位与</font>运算,就可以得到子网地址,然后在路由表中使用<font color="red">最长前缀匹配优先</font>找到对对应的转发接口.</font>

<img src="C:\Users\kkddyz\AppData\Roaming\Typora\typora-user-images\image-20211027142449639.png" alt="image-20211027142449639" style="zoom:80%;" align="left"/>

---

![image-20211027143603588](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211027143603.png)



# 网络层(中)

> 本章是对IP协议的补充

## CIDR与路由聚集(IP补充)

### 什么是CIDR

> CIDR是一个用于给用户*<u>分配IP地址</u>*以及在互联网上<u>*有效地路由IP数据包*</u>的<u>*对IP地址进行归类的*</u>方法。也体现了层级编址的思想.

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211027144452.png" alt="image-20211027144451968" style="zoom:80%;" align="left"/>

> 这个C类地址借的是网络号的最低为,相当于把`200.23.16.0`和`200.23.17.0`两个C类网络融合.所以CIDR作为一种新的划分IP子网的方式提高了IPV4地址空间的分配效率.



### CIDR的优势

1. 提高IPv4地址空间的分配效率
2. 提高路由效率
   1. 将多个子网聚合为一个较大的子网
   2. 这样路由表只需要维护较大子网的转发表信息 -- <font color="red">路由聚合</font>





### 路由聚合

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211027145659.png" alt="image-20211027145658871" style="zoom:67%;" align="left"/>

> 聚合的理由是,这三个子网的接口都是相同的,没必要维护三个目的网络,合并成一个就行了.



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211027145911.png" alt="image-20211027145910874" style="zoom: 67%;" align="left" />

> 对于外部网络 223.1.0.0/22就是一个(逻辑上)完的子网,至于内部怎么转发是子网划分的事情.所以我们可以看出,子网划分与子网聚合是一套相辅相成的技术.将子网划分的子网聚合可以简化(归纳)路由转发表中的IP地址.

---

### 黑洞问题

> 由于历史原因,可能导致`Fly-By-Night-ISP`的连续地址空间缺了一块.也就是图中的组织一 .
>
> 这会导致来自Internet的分组找不到组织一,这杯成为黑洞现象,
>
> 但是我们只要在`ISPs-R-Us`二外增加组织一的网络地址.
>
> 来自Internet的数据报会交给`ISPs-R-Us`,由于<font color="red">最长前缀匹配优先.</font>
>
> 这样即利用了路由聚合好处,又避免了黑洞问题.

![image-20211027150852275](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211027150852.png)



---

## DHCP

### 如何获取IP

两种配置IP的方式

![image-20211027152456062](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211027152456.png)



![image-20211027152743032](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211027152743.png)

---

### DHCP原理

![image-20211027153100223](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211027153100.png)

> 通过广播的方式发送报文.

----

#### DHCP报文交互过程

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211027155208.png" alt="image-20211027155208731" style="zoom:80%;" />

> DHCP服务器端进程port67,客户端port68.
>
> `yiaddr` your ip address
>
> DHCP request仍使用广播的原因是:网络中可能不止一台DHCP服务器,它们已经分配了一个IP,并发出offer报文. 通过广播,让哪些已经分配了IP的DHCP服务器回收IP地址.
>
> 由于request报文中携带了通过offer获取到的IP,所以分配这个IP的DHCP服务器收到这个报文,才会发送DHCP ack报文.

> DHCP ack报文会携带分配给用户的IP地址,子网掩码,DNS服务器地址,默认网关.

---

DHCP协议在应用层实现.请求报文会被封装到UDP段中.

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211027155523.png" alt="image-20211027155523397" style="zoom:67%;" align="left"/>



----

## NAT

> 网络地址转化，在与外部网络交换时，对私有的IP地址进行替换。通过端口号区分不同的数据报的目的主机。实际上就是将整个子网当作一台主机，内部通信就是用私有ip。

### NAT的优势

1. 由于IPv4地址耗尽，使NAT只需要从ISP申请一个地址。

2. 本地网络设备的IP都是私有ip，它的变更对于外界来说是透明的。
3. 变更ISP时，内部网络地址也无需修改。
4. 内部网络设备对于外界是不可见的,即不可直接寻址(安全)

### NAT的实现

#### 原理

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028094637.png" alt="image-20211028094637091" style="zoom:67%;" align="left"/>

#### 具体过程

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028095118.png" alt="image-20211028095118012" style="zoom:67%;" align="left"/>

### NAT带来的争议

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028095620.png" alt="image-20211028095619982" style="zoom:80%;" align="left" />

> 实现NAT的路由器会修改传输层的数据报。

### NAT穿透

>  外网希望能够主动连接到内网一台主机(好像跳过路由器直接建立起连接)
>
> 内网向外网主机提供服务。

#### 什么是NAT穿透？

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028100052.png" alt="image-20211028100052300" style="zoom: 80%;" align="left"/>



#### 如何解决

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028100724.png" alt="image-20211028100724266" style="zoom:100%;" align="left"/>

> 先了解一下

---

## ICMP

### IMCP报文

#### 报文类型

Internet  Control Message Protocol (互联网控制报文协议)支持主机和路由器，实现

1. 差错(或异常)报告 
2. 网络探寻



对应的两类ICMP报文

- 差错报告报文

  - <font color="blue">目的不可达</font>
  - 源抑制(Source Quench) :
  
    - 拥塞控制，路由器的缓存满了
  
    - 在IP中没用，因为IP没有实现拥塞控制，在TCP实现的。
  - <font color="blue">超时：TTL</font>
  -  参数问题：IP数据报的头部信息有问题
  - 重定向：路由器发现自己不是正确的转发者，应该发给另一个人。

- 网络探寻报文
  - 回声(Echo)请求与应答(Reply)报文 
    - ping就是这么时间的
  - 时间戳请求与应答报文

#### 报文编号

ICMP报文通过类型+编码区别。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028102741.png" alt="image-20211028102740777" style="zoom: 50%;" align="left"/>

---

#### 特殊情况

![image-20211028103134168](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028103134.png)

> 不使用的基本都是历史原因遗留。



---

### ICMP报文格式

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028103440.png" alt="image-20211028103439974" style="zoom:80%;" />

> ICMP头部8字节 数据部分，长度取决于是UDP还是TCP？？
>
> ICMP需要封装出差错的IP数据报的完整头部信息，
>
> 还需要加上出差错IP封装的传输层段头部信息，UDP头部只有8字节，TCP头部20字节。



具体封装情况如下图

![image-20211028104257203](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028104257.png)

----

### 应用：TraceRoute

![image-20211028105702424](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028105702.png)



> 通过，”ICMP超时报文“不断反馈路径。直到收到"目的不可达"

---

## IPv6

### IPv6数据报

![image-20211028110146503](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028110146.png)

> IPv6中主机分片，路由器不允许分片。
>
> 快速处理的前提就是IPv6有固定的头部长度40B,而IPv4存在选项字段，因而长度是不确定的。
>
> 扩展首部封装的可能是TCP/UDP的头部之类，这些头部路由器不需要处理。

---

#### 数据报格式<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028110754.png" alt="image-20211028110753926" style="zoom:80%;" align="left"/>

> next header 如果没有下一个选项首部，才会指向上层协议首部。















#### 与IPv4的改变

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028111316.png" alt="image-20211028111316195" style="zoom: 80%;" align="left"/>

---

### 地址表示形式

 128 = 8 * 16 = 8 * (4*4) || 一个16进制数表示位。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028112005.png" alt="image-20211028112005784" style="zoom:67%;" align="left" />

> 为了兼容IPv4，IPv6将前80位都置为0，接下来16位都置为1，就是FFFF,剩下32位写成点分十进制。
>
> URL由于:会导致歧义，所以需要在地址外面加[];



###  IPv6基本地址类型

![image-20211028112759585](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028112759.png)



### IPv6与IPv4的兼容

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028113212.png" alt="image-20211028113212296" style="zoom:67%;" align="left"/>

> IPv6数据报穿越IPv4网络后在将IPv6数据卸载下来。



![image-20211028113709004](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211028113709.png)

> 进入隧道前，边缘的IPv6路由器将数据报封装为IPv4数据报。



---

## 例题讲解

![image-20211029094510999](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029094511.png)

#### 写路由表

![image-20211029093737699](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029093738.png)

> 如图所示，主机路由的子网掩码应该是全1，那么IP其实就是网络号，我们将主机看成一个特殊的网络，网络中只有一台主机。
>
> 互联网的路由应该是缺省路由，即默认路由，路由表里没有匹配项就应该发送到互联网。
>
> 缺省的写法是ip和子网掩码都是全0.



#### 子网划分与聚合

![image-20211029094454385](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029094454.png)

![image-20211029094327416](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029094327.png)

---

# 网络层(下)



## 路由算法

![image-20211030130156350](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030130156.png)

![image-20211030130423593](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030130423.png)

![image-20211030131047954](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030131048.png)



## 链路状态路由算法



![image-20211030140746911](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030140747.png)

> 通过洪范获取全网的节点信息。

![image-20211030140733166](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030140733.png)

### 震荡问题

![image-20211030141054889](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030141055.png)



----

## 距离向量路由算法 

![image-20211030165816205](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030165816.png)

> 怎么和floyed算法不太一样？不是一个东西压根。
>
> 这个是可以处理负权图的单源最短路径算法，但是效率比Dijistra低。



![image-20211030170114224](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030170114.png)



![image-20211030170444440](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030170444.png)



![image-20211030170800684](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030170800.png)



---

### 实例

![image-20211030171442156](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030171442.png)

> 第一阶段 路由表中只有自己的距离向量信息，然后和邻居交换。
>
> 第二阶段 得到邻居的路由向量后，需要重新计算自己的距离向量。
>
> 如果发生变化需要通告给邻居，如果没有就不通告。

---

### 链路费用变化

![image-20211031093559468](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031093600.png)



### 无穷计数问题

> 当链路费用增大，出现的问题。
>
> 出现的原因是？

![image-20211031094753206](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031094753.png)

![image-20211031095405778](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031095406.png)

> 好复杂，听不懂啊！

![image-20211031095839511](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031095839.png)



## 层次化路由(重点)



![image-20211031104135444](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031104135.png)

> 实际网络抽象为一个图是不现实的。



![image-20211031104619653](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031104620.png)

![image-20211031104932747](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031104933.png)



![image-20211031105643139](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031105645.png)

> AC内部通过内部路由选择最近的网关，网关间传输，。。。
>
> 内外部是完全不相关的。这也是层次化的基本思想。



---

## Internet路由协议

internet采用层次化路由协议。

AS内部路由协议也被称为<font color="blue">内部网络协议(interior gateway protocols).  IGP</font>

常见的路由内部协议有

- RIP ( routing information potocols) 路由信息协议
- OSPF (open shortest path  first) 开放最短路径优先
- IGRP (interior gatewat routing potocols) 内部网关路由协议
  - 思科路由器的私有协议

## IGP

### RIP

#### 基本原理

![image-20211031110928721](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031110929.png)

> 适用于小规模网络。跳步数有限。

![image-20211031111137387](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031111137.png)

> 交换的路由表中多了一格下一条起到了毒性逆转的作用。
>
> D发现D->A->C的cost只有5，这里不会经过自己所以没问题。



#### 链路失效，恢复

![image-20211031111532755](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031111533.png)

#### 具体实现

通过一个应用进程实现。

![image-20211031111717168](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031111717.png)

---

### OSPF

open ：指的是公众可用

采用链路状态路由算法。

- LS(link status)分组扩散(通告)
- 每个路由器构造完整的网络(AS)拓扑图
- 利用Dijkstra算法计算路由



OSPF通告<font color="blue">直接封装到IP数据报</font>，在AC内泛洪.



OSPF相比于RIP更加先进.

![image-20211031125133882](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031125134.png)

> 最后一个最重要.



#### 分层的OSPF

分为主干区Backbone,局部区Area.

-  链路状态通告只限于区内
- 每个路由器掌握所在区的详细拓扑

两个区域通过区边界路由器(Area Border Routers)连接.

![image-20211031130121755](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031130121.png)



---

## BGP

- Border Gateway Potocol 边界网关协议



### 概述

<font color="blue">BGP已经成为了事实上的标准域间路由协议.</font>它是将Internet粘合成一个整体的关键。



BGP为每个AS提供了一种手段

- eBGP:从邻居AS获取子网的可达性信息
- iBGP：向所有AS内部路由器传播子网的可达性信息。

<font color="blue">BGP允许子网向整个Internet通告他的位置。</font>



### 存在理由:为什么需要IGP和BGP

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211101175923.png" alt="image-20211101175923511" style="zoom:80%;" align="left" />

> BGP期望为不同的AS提供连接服务。相比与IGP，他需要考虑到策略原因。
>
> IGP则不需要考虑。

### BGP基础



#### BGP会话

两个被称为<font color="blue">peers</font>的路由器通过<font color="blue">BGP会话</font>交换BGP报文。



- <font color="red">作用：</font>通告去往不同<font color="blue">前缀</font>的<font color="blue">路径</font> ，实现路由可达性信息的交换 

  - > 在计网中前缀表示的是一个子网

  - 因此BGP也被称为<font color="blue"> 路径向量协议 path vector</font> 

- 基于半永久的TCP连接

  - 建立后长时间不会拆除







#### BGP报文



open报文 ：与peer建立TCP连接 ，并认证发送方

update报文 ： 告知新路径(撤销原有的路径)

keepalive报文：在无update报文时，保活连接。也用于对open请求的确认。

notification报文：报告先前报文的差错；也用于关闭连接。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031201603.png" alt="image-20211031201603350" style="zoom:80%;" align="left"/>

> AS3通告的前缀的分组可能会被他转发給AS1;



#### BGP分发路径信息

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031202114.png" alt="image-20211031202114095" style="zoom:67%;" align="left"/>



#### BGP路径属性

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211031202745.png" alt="image-20211031202745364" style="zoom:80%;" align="left"/>

> 下一条，是指前往下一个AS的路由器接IP.
>
> 发这个通告是如何告知前缀信息的？？



### BGP路由选择

#### 输入策略(import policy)

网关在收到路由通告后，利用其输入策略(import policy)决定是否接受该路由。



存在这个机制的目的是，可以决定某个AS传输的数据的策略。

(也就是说，我可以拒绝来自某个AS的流量)



因此BGP也被称为 基于策略(policy-based)的路由系统。



---

#### 路由选择策略

如果路由器知道到达某目的AS的多条路由，怎么选择呢？



1. 首先考虑：本地的<font color="blue">偏好值属性（loc-Prf）</font>(体现了<font color="red">策略决策 policy desicion</font>)
   1. 我们会给每一条路由一个值，代表这本AC对这些偏好程度，有限最先local-prf大的线路。
   2. 这个值不是客观的而是基于主观的，可以被修改。
2. 其次是：<font color="blue">最短AS-PATH</font>(不保证经过的路由最少，只是在AS层面上考虑)
3. 最后：考虑<font color="blue">最近的Next-Hop</font>路由器：(最近的出口)
4. 可能还会存在其他准则

---

#### 路由选择案例

网络拓扑结果如下:

![image-20211101173047557](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211101173047.png)

其中

1. A,B,C是<font color="blue">提供商网络</font>/AS(provider network/AS)
2. X,Y,W是<font color="blue">客户网络</font>/AS (customer network/AS)
3. W，X属于<font color="blue">stub network，桩网络</font>,
   1. 只有由一个provider AS接入Internet
   2. 路由表直接<font color="blue">静态配置</font>即可
4. x同时与两个provider AS相连，这被称为<font color="blue">dual-homed AS,双宿为网络</font>
5. 如果与更多个provider AS相连,就称为 <font color="blue">multi-homed AS</font>

> 补充一点：在互联网中只有服务提供商才会提供"过路流量传输"，用户的AS不会这么做。
>
> 这就意味着用户网络只会获取到它IP对应数据报。
>
> 在这里 用户网络x与服务商网络B,C相连，但是x不会承担B->C的流量。
>
> 那么c就不会向B通告前往C的路径，也不会通告C.



通告情况如下：

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211101173047.png" alt="image-20211101173047557" style="zoom:80%;" align="left"/>

A向B通告路径 AW; B向X通告路径 WAB

B不会向C通告路径`WABC`,因为<font color="red">没有收益</font>，WC都不是B的用户。

B不向C通告意味着，C就不知道`BAW`这条路径，只能通过`WACY`。

(所以通告意味着愿意为你提供服务，也需要你的服务)

B只会为到达X或者离开X的路径提供服务。

(WABCX不行嘛 -- 不行因为C只为Y服务

> 一般情况下provider会为他的用户提供服务。
>
> 也就是说provider存在的路径中一定有它的用户。



其实我猜测B也会向C通告，但是C发现路径中不包含X就不会同意(import policy)

---

BGP太复杂了，因此学的只有一点点。

---



# 数据链路层



## 链路层服务

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103200104.png" alt="image-20211103200104636" style="zoom:33%;" align="left"/>

 

<font color="red">流量控制(flow control)</font>

- 协调相邻的发送节点和接收



<font color="red">差错检测 (error detection)</font>

- 信号衰减和噪声会引起误差
- 接受端检测到错误可能会

- - 通知发送端重传
  - 直接丢弃帧



<font color="red"> 差错纠正 (error correction)</font>

- 接受端直接纠正比特差错



<font color="red">通信控制</font>

- 全双工：链路两端节点同时双向传输

- 半双工：链路两端节点交替双向传输。



### 服务的实体：网卡

<img src="https://cdn.nlark.com/yuque/0/2021/png/574020/1635833270888-7854037e-c318-447c-b249-6d126af71dd5.png" alt="img" style="zoom: 50%;"  align="left"/>

在端系统中，链路层的功能和网络层一起集成在的。所以链路层的模型就是这样的 -- 网卡间的通信。



---

## 差错编码

### 基本原理

- 基本原理是通过冗余信息R，来传递bit之间的关系。

示意图如下：

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103180756.png" alt="image-20211103180756343" style="zoom:67%;" align="left" />

> 计算机网络使用的一般是线性分组码。
>
> 分组指的是R的产生只依赖于一个分组的数据(而不是多个)。



不过差错编码不可能保证<font color="red">100%</font> 可靠(可能存在两个完全不一样的数据流的校验码是相同的)



这就涉及到<font color="blue">差错编码的检错能力</font>

### 差错编码的检(纠)错能力





在此之前，需要先了解以下汉明距离



#### 汉明距离

##### 汉明距离的定义

在信息理论中，[Hamming Distance](https://en.wikipedia.org/wiki/Hamming_distance) 表示<font color="blue">两个等长字符串</font>在<font color="blue">对应位置上不同字符</font>的数目.

我们以d(x, y)表示字符串x和y之间的汉明距离。

从另外一个方面看，汉明距离度量了<font color="blue">通过替换字符的方式将字符串x变成y所需要的最小的替换次数。</font> 



##### 汉明权重

<font color="red">对于二进制串ａ和ｂ来说，汉明距离等于ａXORｂ中１的数目。</font>(也就是不一样的位数)

我们又称其为[汉明权重](https://en.wikipedia.org/wiki/Hamming_weight)，也叫做population count或popcount。



##### 字符集的汉明距离

字符集的汉明距离是：编码集中任意两个码字的最小汉明距离。

(也就是说 任意两个码字之间的汉明距离 >= 字符集的汉明距离)

`{0000,0101,1010,1111}` 最小的是 `{0000}`和`{1010}`,即2；

`{000000,010101,101010,111111}`最小的是`{000000}`和`{101010}`，即3；

那么不就能得出编码长度为L的字符集的汉明距离为L/2了？？

当然不是，因为字符集中有的数值不会被用到，比如前缀都是0，那么汉明距离就是L/2-1

---

根据不知道什么理论，可以得出以下结论

![image-20211103182935735](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103182935.png)

----



### 奇偶校验码

####  什么是奇偶校验码

英文为：Parity Check 它有两种校验方法：奇校验和偶校验

**奇校验：原始码流+校验位 总共有奇数个1**

**偶校验：原始码流+校验位 总共有偶数个1**

**它的校验位只有一位，要么是0，要么是1**。并且它的校验码还可以放在码流的前面。如下图

![img](https://pic2.zhimg.com/80/v2-2c0f22d050dcbccef85eacee21de747d_720w.jpg)

#### 算法

![img](https://pic1.zhimg.com/80/v2-ed494a01b2527927febaac2845b51d9c_720w.jpg)

就是根据当前1的数量是奇数还是偶数决定校验位的值。

---

#### 应用场景

奇偶校验码一个最为常见的应用场合就是ASCII码。

ASCII码占用一个字节，低7位是有效位，最高位用作奇偶校验。

![img](https://pic4.zhimg.com/80/v2-75e6aec0f7a6185d3c177b934968459f_720w.jpg)

#### 错误检测能力



**<font color="red">只能检测出奇数个错误。</font>** -- 错两个原来码字中5个1，变成7的1也不会有问题。

例如还是ASCII码 大写字母 A

> 奇校验 正确码流 11000001
>
> **错1位** 11000011 变成了偶数个1，能检测出错误
>
> 错2位 11000010 变成了奇数个1，检测不出错误
>
> **错3位** 11001010 变成了偶数个1，能检测出错误



> 偶校验 正确码流 01000001
>
> **错1位** 01000011 变成了奇数个1，能检测出错误
>
> 错2位 01000010 变成了偶数个1，检测不出错误
>
> **错3位** 01001010 变成了奇数个1，能检测出错误



#### 奇校验还是偶校验 

那么使用中是选择奇校验还是偶校验呢？ 其实都有应用了。

<font color="blue">奇校验一个重要的特征是产生不了全0代码</font>，所以在实际操作过程中选择的时候要考虑到这一点

---

### Internet校验和

算法基本思想 就是每16bit相加，出现进位就进行<font color="red">加法回卷</font>，最后取反码。

实例如下：

> **设有三个 16 比特字： 0110011001100000，0101010101010101，1000111100001100。
> 计算它们的 Internet 校验和**
>
> 首先我们应该先两两相加
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103192522.png" alt="image-20211103192522256" style="zoom:80%;" align="left" />
>
> 继续累加
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103192621.png" alt="image-20211103192621555" style="zoom:67%;" align="left"/>
>
> *加法回卷则应该将第十七位与后面的十六位相加* 其实就是sum++;
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103192753.png" alt="image-20211103192753697" style="zoom: 80%;" align="left"/>
>
> 最后取反码
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103192837.png" alt="image-20211103192837731" style="zoom:80%;" align="left"/>



### CRC校验码



CRC校验计算速度快，检错能力强，易于用编码器等硬件电路实现。从检错的正确率与速度、成本等方面，都比奇偶校验等校验方式具有优势。因而，CRC 成为计算机信息通信领域最为普遍的校验方式。常见应用有以太网/USB通信，压缩解压，视频编码，图像存储，磁盘读写等。



[参考视频](https://www.bilibili.com/video/BV1V4411Z7VA?from=search&seid=6719464867891223587&spm_id_from=333.337.0.0)



#### 计算过程

![image-20211103194141523](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103194141.png)

![image-20211103194426615](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103194426.png)



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103195158.png" alt="image-20211103195158099" style="zoom:150%;" />

> 如果最后结果是 0 000011 注意补0带crc.len-1;

---



## 多路访问控制(MAC)



### 出现原因

网络中的链路大致分为两类

- 点对点"链路" ,主要有以下几种

  - 拨号接入PPP
  - 以太网交换机与主机之间的点对点链路

- 广播链路(共享介质)

  - 早期总线以太网
  - 802.11无线局域网

  ![image-20211103200507073](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103200507.png)

> 多个对象共享介质，就需要协议去协调谁来发送数据(同时传输数据,会造成混乱)



---

MAC处理的场景就被称为<font color="blue">单一共享信道</font>。

当两个结点或以上同时传输，就会产生干扰，被称为<font color="red">冲突</font>。

冲突会导致接收方接收失败。

因此需要MAC协调避免冲突的发生。



---



### MAC协议的实现思路

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103201348.png" alt="image-20211103201348042" style="zoom:80%;" align="left"/>

> 我们期望MAC协议采用分布式算法：每个结点按照算法自行决策，而不需要一个其他的结点来集中协调。



理想中的MAC协议应该实现以下目标：

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103201555.png" alt="image-20211103201555178" style="zoom:67%;" align="left"/>



### MAC协议分类

按照实现思路的不同分为三类

![image-20211103201951672](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103201951.png)



### 信道划分

> 类似于cpu调度的时间片轮转法。

![image-20211103202233374](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103202233.png)

![image-20211103202347971](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103202348.png)



> 缺点：在网络负载较轻时，利用率很低。

---

### 随机访问MAC协议

它的基本思想是：

<font color="blue">当结点想要发送分组时，利用信道的全部数据速率R发送数据，没有事先的结点间协调。</font>



但是这势必会造成冲突，想要解决冲突就需要解决以下两个问题。

1. <font color="blue">如何检测冲突？</font>
2. <font color="blue">如何从冲突中恢复？</font>



典型的随机访问MAC协议有

- 时隙(sloted)ALOHA
- ALOHA
- CSMA,CSMA/CD,CSMA/CA



## ALOHA协议

### 时隙ALOHA协议

#### 实现思路

![image-20211103204232802](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103204232.png)





> 要想保证所有结点都是在时隙开始时发送数据，就一定存在全局时钟，实现时钟同步。

> 随机发送的目的是避免冲突，保证可能出现一个时隙中只有一个数据帧的情况。

#### 实例

![image-20211103204625781](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103204625.png)

> C 冲突 collision E empty 空闲 S succss



#### 优缺点

![image-20211103204842487](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103204842.png)

> 缺点3的意思是,开始传输时就应该发现有冲突,后面的数据就没必要传了.



#### 效率低

![image-20211103205027582](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103205027.png)



### 纯ALOHA

![image-20211103205232135](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103205232.png)

> 时隙ALOHA的冲突区间是一个时隙,纯ALOHA是两个时隙.
>
> 冲突的概率变大,效率肯定降低.

![image-20211103205404580](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211103205404.png)



---



> ALOHA协议效率低的原因是**<font color="red">自私</font>**：结点在使用信道之前不会考虑其他结点是否正在使用，结果就导致很大概率出现冲突，从而浪费时隙。



----

## CSMA协议

- 载波监听多路访问协议



<font color="blue">实现原理：</font>

在发送帧之前，监听信号(载波)；当监听到信道空闲，发送完整帧。



<font color="blue">推迟策略</font>

如果信道忙，则会采取推迟发送的措施(主要有三种策略)

- 非坚持：随机等待一段事件，然后再发送数据帧。

- P-坚持：概率P坚持到空闲发送，概率1-P随机等待一段事件，然后发送数据帧。

- 1-坚持：一直监听信息直到空闲。



<font color="blue">但是由于<font color="red">信号传播延迟</font>，依旧可能发生冲突。</font>

在t0时刻，结点A开始传输数据，信道占用的信号需要通过t才能传播到B;

那么对于B来说，`[to,to+t]`时间段内信道是空闲的，可以发送数据。此时由于A正在发送数据，所以会产生冲突。



<font color="blue">存在问题：不能在冲突时及时终止传输</font>

普通的CSMA协议，在数据的发送过程中是不会中断的。当发生冲突时，依旧会继续发送数据帧，这会导致信道资源的浪费。(正确的做法是两方都停止传输，并等待随机一段时间)。



在传输时同时监听信道是否有其他数据，如果有，即使终止传输。这样就可以大大减少信道资源的浪费。



这就是CSMA/CD协议



### CSMA/CD

> 不是说其他CSMA协议无法检测冲突
>
> CSMA/CD的特点是可以在短时间内检测到冲突，这样减少较多的信道资源浪费。	

CD : collision detection

### 冲突检测的实现

对于有线局域网易于实现：测量信号强度，比较发射信号与接收信号。

无线局域网很难实现：接收信号强度淹没在本地发射信号强度下。

> 无线信号在空气中衰减的太快了。所以本地发射信号极强，而接收到的信号很弱。





----

### 协议的特点

<font color="red">边发边听，不发不听。</font>

要满足这个条件就需要考虑到<font color="red">传输延迟问题</font>

![image-20211104164715243](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211104164715.png)

> 数据帧的传输时间一定要大于两个最大延迟(RTT)。 
>
> 否则，距离太远，等到B的信号传过来，A的数据都传完了。
>
> 当两个帧在链路的某处相遇发生冲突后，由于A已经停止了监听，检测不到冲突了。
>
> 那么这种协议就不可靠了：<font color="blue">冲突发生，但是没有被检测到.</font>



基于协议的这种特点,就必须限制帧的大小: <font color="blue">帧传输时间>RTT</font>

![image-20211104165442046](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211104165442.png)

> L`min` 最小帧大小; R传输速率； d`max` 介质长度; V信号传递速度。

---

#### 例题

![image-20211104165719248](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211104165719.png)

---

### 效率

![image-20211104165757605](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211104165757.png)

---

## 轮转访问MAC

先分析以下之前两种MAC协议的问题.

![image-20211104171117587](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211104171117.png)

> 以某种规则让结点依次使用信道.

### polling

> 如果前3个结点都不发送数据,第4个结点需要发送数据.这是需要额外等待3个RTT.

![image-20211104171642947](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211104171643.png)

> 比如：检测气候数据的基站会被检测中心polling，获取数据。

### token passing

![image-20211104172126949](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211104172127.png)

> 令牌网络往往成一个环形,使得数据沿一地的方向传播.
>
> 结点没有数据就把令牌传给下一个结点.如果有数据要发送,就捕获令牌.

> 当超过一段时间没有任何数据发送，就会认为令牌丢失了，重新生成一个令牌。

---

## 总结

![image-20211104172230157](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211104172230.png)



---





> 之前的一章主要讲了数据链路层可靠传输的实现，涉及两个方面
>
> 1. 差错检测与纠错
> 2. 单一共享信道的MAC协议
>
> 在此基础上，我们才能去考虑如何实现链路层的组帧，以及帧的地址。

---

# 局域网(以太网很重要)

## ARP协议

### MAC地址

MAC地址又被称为<font color="blue">LAN(loacl area network)地址,物理地址，以太网地址。</font>

作用：<font color="blue">在局域网内标识数据帧从哪个接口出发，到达哪个物理相连的其他接口。</font>

一般，48位MAC地址被固化在ROM中，也可以被修改。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113155457.png" alt="image-20211113155457129" style="zoom:80%;" />

---

#### MAC地址管理

为了保证MAC地址的唯一性，显然我们需要有一个人来统一管理MAC地址。

这个人就是IEEE.



网卡生厂商需要<font color="blue">购买MAC地址空间</font>(前24位)，然后为它生产的网卡设置唯一MAC地址。



#### MAC与IP的类比

![image-20211113160036604](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113160036.png)

---

### 为什么需要ARP协议

现在在LAN中有一个问题。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113160354.png" alt="image-20211113160354652" style="zoom:50%;" align="left"/>

> 网络层将数据封装到链路层，如何根据其IP获取对应的MAC地址？

<img src="C:\Users\kkddyz\AppData\Roaming\Typora\typora-user-images\image-20211113160623090.png" alt="image-20211113160623090" style="zoom:50%;" align="left"/>

> TTL是为了可以定时更新ARP表。



### 如何获取某IP对应的MAC地址？

如果A想要给B发送数据包，而A的ARP表中没有B的MAC地址。

这时，A会在LAN中<font color="blue">广播ARP查询分组</font>,其中包含B的IP地址。

> MAC广播地址和IP类似全1：FF-FF-FF-FF-FF-FF

所有结点都会收到ARP查询分组，B的IP匹配成功，向A应答B的MAC地址。

> 广播ARP查询分组有A的MAC地址，所以B向A发出的是单播帧。

A在其ARP表中缓存B的IP-MAC地址对，直至超时。



### ARP特点：即插即用

结点自主创建ARP表，无需干预



---

以上ARP协议中的A，B在同一个局域网中。

如果两个结点不在同一个局域网中A该如何获取B的MAC地址呢？

---

### 寻址：从一个LAN路由至另一个LAN

![image-20211113164144299](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113164144.png)

> B的IP地址由用户指定，可能是DNS转化得到的，也可能是用户提供的。
>
> 路由器的多个接口的IP是不同的
>
> 111.111.111.110是左侧子网的网关。
>
> 222.222.222.22o是右侧子网的网关。



第一步

![image-20211113164735775](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113164736.png)

第二步

![image-20211113164808591](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113164808.png)

第三步

![image-20211113164825854](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113164826.png)

> 如果子网是私网，就需要NAT.



---

### 总结

ARP协议构建起了MAC和IP的桥梁。

IP是全网统一的，但是链路层的网络结构可能是不同的，但是通过ARP将不同网络结构中链路层节点的MAC与IP建立连接。



---

## IEEE 802.3 以太网

统治地位的有线LAN技术。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113173739.png" alt="image-20211113173738999" style="zoom: 50%;" align="left" />

### 拓扑结构

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113174125.png" alt="image-20211113174125133" style="zoom:67%;" align="left"/>



### 提供不可靠，无连接服务

![image-20211113174401412](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113174401.png)

> 高层协议去实现可靠性和连接。(网络层，传输层)

> 二进制指数退避算法：计算等待重发的时间

---

### 以太网 CSMA/CD算法

![image-20211113175144020](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113175144.png)

> NIC 网卡
>
> 连续冲突次数越多，随机等待时间越长

---

### 帧结构

802.1协议帧

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113175643.png" alt="image-20211113175642897" style="zoom:80%;" align="left"/>

> 一般在讨论以太网帧的长度是不考虑前导码的。



![image-20211113180136255](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113180136.png)



---

### 以太网标准

主要是速率和链路介质的区别。 MAC协议和数据帧格式是相同的。

![image-20211113180259045](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211113180259.png)



---

## 交换机

### 概述

`交换机的主要作用`

- 交互机是<font color="blue">链路层设备</font>

- 作用：用于<font color="blue">存储和转发以太网帧</font>。
  - 转发的原理：通过<font color="blue">检验到达帧的目的MAC地址</font>，<font color="red">选择性</font>的向一个或多个输出链路转发帧。
  - 转发遵循的协议：<font color="red">CSMA/CD;</font>

`交换机的特点`

1. 交换机对于主机来讲是<font color="red">透明的</font>，主机感知不到交换机的存在。

2. 交换机有<font color="red">自学习</font>的特点(无需配置)，属于<font color="red">即插即用</font>的设备。

3. 交换机可以<font color="red">并行交换信息: 多端口见同时传输</font>

   ![image-20211115183610756](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115183611.png)

---

### 交换机原理

#### 转发表

每一个交换机都会维护一个交换表。

表中包含主机的MAC地址，到达主机的接口，时间戳TTL;

#### 自学习

交换表中的信息通过自学习得到。

每当交换机收到帧，就会学习源主机的MAC和对应的接口，然后记录到交换表中。

#### 帧过滤/转发

转发时，交换机检索目的MAC地址的匹配项。

如果找到了

- 并且<font color="blue">目的主机位于收到帧的网段</font>（就是说目的主机和发送的主机接在同一个接口），直接丢弃。
- 如果不在同一个网段，则将帧转发到指定的接口。

如果找不到(还没有学习到)，就<font color="red">泛洪</font>（向该接口以外的所有接口转发）。

---

#### 总结 + 例子

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115185656.png" alt="image-20211115185656174" style="zoom:80%;" align="left"/>



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115190125.png" alt="image-20211115190125321" style="zoom: 33%;" align="left"/>

> 一开始：A向A'发送数据帧，交换机学习到A在接口1；
>
> 但是由于交换机不知道A'，因此交换机泛洪2,3,4,5,6接口，最终4接收到了数据帧。
>
> 然后：A’回复A,此时交换机学习到A'在接口4，由于已经学习到A在接口1，因此使用选择性转发。

---

### 交换机互联

#### 多交换机自学习举例

![image-20211115194041187](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115194041.png)

> 具体过程视频没有讲，网上也没找到。
>
> 但是我估计应该时这样：
>
> CH这个帧到S1,会泛洪，S4接收到之后会学习到A对应的接口就是S1连接到S4的接口。
>
> S1所有设备对应的接口都是一样的。



---

#### 典型的组织机构网络

![image-20211115194819618](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115194819.png)

> 广播域被路由器隔绝，冲突域被交换机隔绝。



---

### 链路层设备

![image-20211115195106370](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115195106.png)



![image-20211115195358984](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115195359.png)

>集线器现在基本不用了，所以不讲；
>
>交换机和网桥的原理基本一致。
>
>直通传输：就是可以边收边发。

---

## 虚拟局域网

### 提出原因

基于两种情况

![image-20211115203450126](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115203450.png)

1. 由于交换机不隔离广播域，EE系的主机不希望收到CS,CE的泛洪。
2. CS用户迁移到EE,但是还是希望使用CS的交换机

---

### 概述

![image-20211115203746708](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115203746.png)

### VLAN的实现原理

实现的基本思想是对交换机的端口分组

![image-20211115203844375](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115203844.png)

从而在逻辑上形成多个虚拟交换机。

![image-20211115203914728](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115203914.png)

---

也可以对MAC地址分组，定义不同的VLAN;

这样端口可以被动态的分配给VLAN中的MAC地址。



VLAN之间的转发需要路由器实现。

(在实践中，厂商会把交换机和路由器集成到一起)

---

### 跨越多交换机的VLAN

![image-20211115205403465](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115205403.png)



![image-20211115205609143](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115205609.png)



---

## PPP协议

![image-20211115210138425](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115210138.png)



### PPP设计需求



![image-20211115210613424](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115210613.png)

![image-20211115210644289](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115210644.png)

> 由高层协议处理

---

### PPP数据帧

![image-20211115211041926](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211115211042.png)

> 点对点不需要MAC地址。
>
> MAC使用前导码实现帧同步，PPP通过定界符。
>
> 地址字段和控制字段是可以通过协商省略的。
>
> protocol可以只有1字节，check2字节，所以一共可以省略5字节



### 比特透明传输：字节填充

PPP设计需求中要求实现<font color="blue">比特透明传输</font>;

也就是说数据帧的info字段里面允许存在与flag重复的`01111110`.

处理手段是在会引起歧义的 `01111110`前面增加`01111101`

同样 `01111101`也需要填充 `01111110`.

![image-20211116183116346](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211116183116.png)



#### PPP协议负责实现字节填充

![image-20211116183226196](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211116183226.png)

---

不是很重要，就先看这么多。



---

## IEEE 802.11无线网



我们常用的是802.11b协议

![image-20211116185048416](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211116185048.png)



感觉用不到，跳过。



---

# 物理层 + 网安 (跳过)

# 总结

2021-11-16

第一次，看完一边。东西其实很多，不过里面由很多东西用不到，我打算第二遍的时候重新做一遍笔记。

我会把不重要的东西标注出来(等复习的时候)。

