

# 树(上)

## 树

> 树的本质：一种层次化的数据管理方式。
>
> 数据以树的形式管理可以提高数据的操作效率：查找 O(logn)，插入,删除O(1)

### 树的基本概念

#### 定义

定义：n(n >= 0)个结点构成的有限集合。

- n=0,称为空树。

对于任意一个非空树

- Root结点，用r表示	
- 其余结点可以分为m个<font color="red">互不相交</font>的有限集T1,T2...;其中每个结点都是一个子树。

---

#### 判断是否是树

判断是否是树

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127154936.png" alt="image-20211127154936015" style="zoom:80%;" align="left"/>

> 相交表现为：一个结点有多个父节点。
>
> 子树不相交，所以只有n-1条边。

通过边的数量判断 定义 边数量 e 节点树 n，树必须满足 n = e-1；

通过递归分别计算n,e;

不可行，无法计算节点个数。

```java
// 计算子树边个数
public int countE(Root r){
	// 当前不是空节点
	if (r != null){
		return countE(r.left) + countE(r.right);
	}else {
		// 递归终止
		return 0;
	}
}
```

 

主要思路，每一个节点除了root只有一个parent

---

#### 术语

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127155228.png" alt="image-20211127155228175" style="zoom:80%;" align="left"/>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127155415.png" alt="image-20211127155415666" style="zoom:80%;" align="left"/>

---

### 树的表示

> 通过儿子兄弟表示法，任何一棵树都可以转换成一颗二叉树。
>
> 因此儿子-兄弟表示法将树一般化为二叉树，是我们研究树问题的前提



首先，数组是只能实现完全树而且需要约定节点的度数。

其次，链表实现的时候。如果结点定义固定数量的child，比如3，会导致空间浪费。



如果希望使用统一的结点结构，并且表示任何组织形式的树

以下方法可以满足。



#### 儿子-兄弟表示法

- 基本思路，就是first child 指向下一个层次，即儿子。nextSibling采用链表的方式指向某个兄弟。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127160216.png" alt="image-20211127160216269" style="zoom:80%;" align="left"/>

---

#### 二叉树 -- 树的一般形式

将树旋转以下，就可以得到下图

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127160405.png" alt="image-20211127160405735" style="zoom:80%;" align="left"/>

> firsrtChild nextSibling是 left，right的一种语义化表示。
>
> 也就是说<font color="red">二叉树可以通过"儿子-兄弟表示法"表示任何结构的树。</font>
>
> 因此，我们对树的研究主要集中在二叉树上。

---

## 二叉树

> 二叉树的查找模拟了二分法。链表不可以，查找效率O(n)
>
> 而他的插入删除又是数组不擅长的，数字需要O(n).

### 概念

#### 定义

二叉树T

- 一个有穷的结点集合。
- 这个集合可以为空；
- 若不空，则它由根节点和左右子树，T`L`,T`R`，两个不相交的子树构成

#### 特殊二叉树

![image-20211127163057041](C:\Users\kkddyz\AppData\Roaming\Typora\typora-user-images\image-20211127163057041.png)

> 完全二叉树，相比于完美二叉树就是缺少最后几个结点。
>
> 节点的缺失不会影响对节点的编号。



#### 二叉树的性质

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127164021.png" alt="image-20211127164020996" style="zoom:80%;" align="left"/>

> 结论3的证明过程
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127164152.png" alt="image-20211127164152352" style="zoom: 25%;" align="left" />

---

### 存储结构

#### 抽象数据类型

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127164330.png" alt="image-20211127164330779" style="zoom:80%;" align="left"/>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127164421.png" alt="image-20211127164421644" style="zoom:80%;" align="left"/>



#### 数组实现

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127174227.png" alt="image-20211127174227582" style="zoom: 100%;" align="left"/>

> 按照层次对结点编号填入数组。
>
> 当前节点所在数组下标/2就是父节点所在数组下标
>
> childIndex/2 == parentIndex

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127174422.png" alt="image-20211127174422095" style="zoom:100%;" align="left"/>



#### 链表实现

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127174609.png" alt="image-20211127174609582" style="zoom:100%;" align="left"/>

---

### 二叉树的遍历(重点)

![image-20211127181134607](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127181134.png)

> 遍历的本质是将2维的树变成一维的序列，不同的遍历方式就会产生不同的序列。
>
> 非递归的方式遍历的问题在于，子节点必须通过其父亲才能被访问。
>
> 当一个结点入栈，访问它的左儿子，如果此时将该结点抛出，我们就找不到它的右儿子了，但是如果不抛出，就无法模拟print自己。所以我们需要第二个堆栈。
>
> 在考虑层序遍历的时候也是一样，使用队列在父亲出队前必须将两个儿子都入队。

#### 递归实现

##### 先序遍历

![image-20211127174919074](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127174919.png)

##### 中序遍历

![image-20211127175045968](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127175046.png)

##### 后序遍历

![image-20211127175240675](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127175240.png)

#### 前中后序比较

![image-20211127175342811](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127175342.png)

> 所谓的三次遇到结点，实际上是指当前函数调用完成需要执行三行代码
>
> - print当前
> - print左子树
> - print右子树
>
> 不同的遍历方式print当前调用的位置不一样。
>
> 如果是在第一次遇到(print在第一行)就是先序。
>
> 如果等左子树打印完成，回到当前函数，(print在第二行)就是中序。
>
> 如果等到右子树打印完成，回到当前函数，(print在第三行)就是后序。

#### 非递归实现

比较麻烦，先不看。

首先啊模拟出递归的调用顺序。

```JAVA
private List<Integer> result = new ArrayList<>();
private Deque<TreeNode> stack = new LinkedList<>();

public List<Integer> preorderTraversal(TreeNode root) {
    
    Deque<TreeNode> stack = new LinkedList<>();
    // cur表示当前访问的节点
    TreeNode cur;

    // 压入左枝
    pushLeft(root);

    // 抛出栈顶元素(抛出该元素表示其左子树访问完成)
    while ((cur = stack.pollFirst()) != null) {
        // 压入cur.right的左枝
        pushLeft(cur.right);
    }
    return result;
}

// 压入左枝(也就是node node.left node.left.left)
private void pushLeft(TreeNode node) {
    while (node != null) {
        // 在入栈前访问
        result.add(node.val);

        // 将结点入栈
        stack.addFirst(node);
        node = node.left;
    }
}
```

先序遍历就是在 `stack.addFirst(node)`之前访问，中序就是在 `cur = stack.pollFirst()`时访问。

入栈表示，结点已经被访问到，出栈表示左子树遍历完成。



因此很容易，写出 先序和中序遍历的代码(只需要一个栈)。



##### 先序遍历

```JAVA
class Solution {

    private List<Integer> result = new ArrayList<>();
    private Deque<TreeNode> stack = new LinkedList<>();

    public List<Integer> preorderTraversal(TreeNode root) {

        // cur表示当前访问的节点
        TreeNode cur;

        // 压入左枝
        pushLeft(root);


        // 抛出栈顶元素(抛出该元素表示其左子树访问完成)
        while ((cur = stack.pollFirst()) != null) {

            // 压入cur.right的左枝
            pushLeft(cur.right);
        }

        return result;
    }

    // 压入左枝(也就是node node.left node.left.left)
    private void pushLeft(TreeNode node) {
        while (node != null) {
            // 在入栈前访问
            result.add(node.val);

            // 将结点入栈
            stack.addFirst(node);
            node = node.left;
        }
    }
}
```



##### 中序遍历

```JAVA
class Solution {

    private List<Integer> result = new ArrayList<>();
    private Deque<TreeNode> stack = new LinkedList<>();

    public List<Integer> inorderTraversal(TreeNode root) {

        // cur表示当前访问的节点
        TreeNode cur;

        // 压入左枝
        pushLeft(root);


        // 抛出栈顶元素(抛出该元素表示其左子树访问完成)
        while ((cur = stack.pollFirst()) != null) {

            // 出栈时访问
            result.add(cur.val);

            // 压入cur.right的左枝
            pushLeft(cur.right);
        }

        return result;
    }

    // 压入左枝(也就是node node.left node.left.left)
    private void pushLeft(TreeNode node) {
        while (node != null) {

            // 将结点入栈
            stack.addFirst(node);
            node = node.left;
        }
    }
}
```







##### 后序遍历

后序遍历非递归算法比较复杂。由于后序遍历要求左、右子树都访问完后，最后访问根节点。说明节点在第一次出栈后，还需再次入栈。也就是说，节点要入两次栈，出两次栈，而访问节点是在第二次出栈时访问。



前中后序的非递归实现过程中，结点的入栈顺序是一致的，区别在于何时出栈。

中序遍历，在结点第一次入栈后，当后压入的左子树所有结点都出栈，

结点位于栈顶，意味着左子树遍历完成。



前/中序遍历 

1. root入栈，按照递归顺序将所有左子树结点入栈 
2. root出栈，左子树遍历完成

后序遍历

1. root入栈，按照递归顺序将所有左子树结点入栈 
2. root出栈，左子树遍历完成
3. root入栈，按照递归顺序将所有右子树结点入栈 
4. root出栈，右子树遍历完成

> 对于前中序遍历来说，什么时候出栈其实不重要。
>
> 我们可以用后序遍历的模拟完整的调用
>
> 1. 当a入栈，开始访问a为root的子树。
> 2. a出栈，子树访问完成

使用一个flag，falg= false 不能出栈(此时左子树遍历完成) falg = true，可以出栈

使用hashMap，存储TreeNode对应的flag

```JAVA
    // flags = false 没有访问cur的右子树，重新压入cur
    private Map<TreeNode,Boolean> flags = new HashMap<>();
    private List<Integer> result = new ArrayList<>();
    private Deque<TreeNode> stack = new LinkedList<>();

    public List<Integer> postorderTraversal(TreeNode root) {

        TreeNode cur;
        pushAllLeft(root);
        
        // 抛出栈顶元素
        while( (cur = stack.pollFirst()) != null){
            // 如果没有访问右子树
            if (!flags.get(cur)){
                
                // 中序遍历 在此 result.add(cur.val);
                // 将结点再次压入，开始访问右子树
                stack.addFirst(cur);
                pushAllLeft(cur.right);
                // 将标记置为true
                flags.put(cur,true);
            }else{
                // 访问了右子树，直接抛出
                // 后序遍历 在此 result.add(cur.val);
                result.add(cur.val);
            }
        }
        return result;
    }


    // 将左枝结点入栈
    private void pushAllLeft(TreeNode node){
        while(node != null){
            // 入栈前 初始化 : 没有访问右子树
            flags.put(node,false);
            // 前序遍历，在此result.add(cur.val);
            stack.addFirst(node);
            node = node.left;
        }
    }
```











#### 层序遍历

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127181216.png" alt="image-20211127181216511" style="zoom:80%;" align="left"/>

---

# 树(中)

## 二叉搜索树(重点)



### 定义

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127195820.png" alt="image-20211127195819949" style="zoom:100%;" align="left" />



### 查找

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127195955.png" alt="image-20211127195955599" style="zoom:80%;" align="left" />

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127200053.png" alt="image-20211127200053036" style="zoom:80%;" align="left"/>

### 插入

首先回顾二叉搜索树的性质：对于任意节点root而言，左子树（如果存在）上所有节点的值均小于root.val，右子树（如果存在）上所有节点的值均大于root.val，且它们都是二叉搜索树。

因此，当将val 插入到以root 为根的子树上时，根据val 与root.val 的大小关系，就可以确定要将val 插入到哪个子树中。

1. 如果该子树不为空，则问题转化成了将val 插入到对应子树上。
2. 否则，在此处新建一个以val 为值的节点，并链接到其父节点root 上。



```JAVA
public TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }

    if (val < root.val) {
        root.left = insertIntoBST(root.left, val);
    } else {
        root.right = insertIntoBST(root.right, val);
    }
    return root;
}
```

> 递归实现比较简单

```JAVA
public TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }
    
    TreeNode pos = root;
    
    // 题目保证没有重复值，插入一定会成功，通过break跳出循环
    while (true) {
        if (val < pos.val) {
            
            if (pos.left == null) {
                pos.left = new TreeNode(val);
                break;
            } else {
                pos = pos.left;
            }
        } else {
            if (pos.right == null) {
                pos.right = new TreeNode(val);
                break;
            } else {
                pos = pos.right;
            }
        }
    }
    return root;
}
```



### 删除(难点)

#### 情况分析



##### 基础情况

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127200958.png" alt="image-20211127200957970" style="zoom:80%;" align="left"/>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127201026.png" alt="image-20211127201026408" style="zoom:80%;" align="left" />

##### 复杂情况

![image-20211127202418220](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127202418.png)

> 选择左子树的最大值，或者右子树的最小值的好处是
>
> 1. 刚好代替原来的元素，依旧是二叉搜索树
> 2. 这两个结点都只有一个孩子，方便删除。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220923174046.png" alt="image-20220923174046038" style="zoom:50%;" align="left"/>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220923174058.png" alt="image-20220923174058163" style="zoom:50%;" align="left"/>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220923174110.png" alt="image-20220923174110515" style="zoom:50%;" align="left"/>

#### 思路分析

![image-20220923171819684](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220923171820.png)

successor至多一个child，删除successor时 successor的child替换successor的位置，successor替换child位置。



```JAVA
 // 分为两个部分 1， 定位  2. 删除
 // 如果定位不到，即删除不存在的结点，不会产生影响
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {

        // key不存在，递归终止
        if(root == null) return null;
        
        if (key < root.val){
            root.left = deleteNode(root.left,key);
            return root;
        }else if(key > root.val){
            root.right = deleteNode(root.right,key);
            return root;
        }else{
            // 删除 

            // 1. 叶子结点 直接删除
            if (root.left == null && root.right == null){
                return null;
            }else if(root.left != null && root.right != null){
            // 2. 两个child 
                // 2.1 寻找右子树的最小值作为successor 
                TreeNode successor = root.right;
                while(successor.left != null){
                    successor = successor.left;
                }
                // 2.2 删除successor (让successor.right代替successor)
                root.right = deleteNode(root.right,successor.val);

                // 2.3 successor代替root
                successor.right = root.right;
                successor.left = root.left;

                return successor;
            }else{
            // 3. 一个child 使用child代替删除结点位置
                return (root.left != null) ? root.left : root.right;
            }
        }
    }
}
```









---

## 二叉平衡树



### 引入

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127202656.png" alt="image-20211127202656742" style="zoom:80%;" align="left" />

根据这个图我们可以发现，越平衡的树，它的ASL越小，查找性能也越高。

这里说的平衡就是指root两边的结点数量差不多。

---

### 二叉平衡树的定义

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127203244.png" alt="image-20211127203244220" style="zoom:80%;" align="left" />



### 平衡二叉树的调整(难点)

#### RR旋转

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127203749.png" alt="image-20211127203749043" style="zoom:80%;" align="left"/>

> A<B`L`<B；所以移动到A的右边。 

RR旋转的例子

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127204110.png" alt="image-20211127204110198" style="zoom:50%;" align="left" />

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127204229.png" alt="image-20211127204229341" style="zoom:50%;" align="left"/>

> 插入的结点在左右都可以，右子树的右子树指的是被插入的结点14与根节点5.
>
> 反正和父亲14在一起。



调整实际上是局部调整(不是调整整个子树)，将高度为3的树变成2.

![image-20211127210207916](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127210208.png)

---

#### LL旋转

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127204503.png" alt="image-20211127204503332" style="zoom:80%;" align="left" />

> B<B`R`<A,所以从 oldRoot.right移动到 newRoot.left

---

#### LR旋转

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127204853.png" alt="image-20211127204853565" style="zoom:80%;" align="left"/>

> B<C<A所以调成C在中间。

---

#### RL旋转

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127210424.png" alt="image-20211127210424107" style="zoom:80%;" align="left"/>



---

# 树(下)

## 堆

### 前言：优先队列

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127211134.png" alt="image-20211127211133985" style="zoom:80%;" align="left"/>

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127211442.png" alt="image-20211127211442843" style="zoom:80%;" align="left"/>

> 如果使用二叉树，既能像数组通过2分查找在O(logn)内查找到元素，又能像链表在O(1)内实现插入删除。



如果用二叉树实现，那么每个根节点都是所在树的最大值。

> 如果不这样，删除的时间复杂度就是O(logn)



### 数据结构

> 使用完全二叉树模拟堆栈，底层实际上是一个数组

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127212242.png" alt="image-20211127212242157" style="zoom:80%;" align="left"/>

#### 有序性



> 有序性体现在root-leaf任何一条路径上的元素都是有序的。
>
> 从root到叶节点，最大堆降序排列，最小堆升序排列。
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127212630.png" alt="image-20211127212630370" style="zoom:80%;" align="left" />

---

### 基本操作

#### 抽象数据类型描述

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211127212805.png" alt="image-20211127212805317" style="zoom:80%;" align="left"/>

---

#### 插入元素(重要)

> 实现思路：
>
> 插入的元素放在数组的最末尾，相当于挂在叶节点位置。
>
> 插入后的元素为了保证堆的有序性，以冒泡的方式与其父节点交换位置。
>

> 在如图所示的堆中插入7
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211129220829.png" alt="image-20211129220829462" style="zoom:80%;" align="left"/>
>
> ---
>
> ```java
> // i一开始指向数组的最后一个元素(index=0不放元素)，模拟树的新插入结点 
> int i = size++; // 如下图
> ```
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211129221117.png" alt="image-20211129221117453" style="zoom:80%;" align="left"/>
>
> ---
>
> ```
> // 如果父节点小于item，向下移动到space
> for (; elements[i / 2] < item; i /= 2) {
> 	elements[i] = elements[i / 2];
> }
> ```
>
> ---
>
> ```
> // 移动结束后i依旧指向space,填入item即可
> elements[i] = item; // 如下图
> ```
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211129221754.png" alt="image-20211129221754600" style="zoom:80%;" align="left" />
>
> ---
>
> 完整代码如下：
>
> ```JAVA
> // item是要插入最大堆的元素  
> boolean insert(int item) {  
> 
>     // heap满了
>     if (size == capacity) {
>         return false;
>     }
> 
>     // 指向数组的最后一个元素(index=0不放元素)，模拟树的新插入结点
>     int i = size++; 
> 
> 
>     // 如果父节点小于新插入结点，父节点下移
>     for (; elements[i / 2] < item; i /= 2) {
>         elements[i] = elements[i / 2];
>     }
> 
>     // 移动结束后i依旧指向space,填入item即可
>     elements[i] = item;
>     return true;
> }		
> ```
>
> 

---

#### 删除元素

> 最大堆的删除，删除的元素是就处于index=1位置的最大值。
>
> 删除后，如何移动元素，保证堆的有序性就是删除的关键问题。
>
> ---
>
> 删除如图所示的最大值
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211129222955.png" alt="image-20211129222955670" style="zoom:80%;" align="left"/>
>
> ---
>
> 将31，即数组中的最后一个元素移到root位置。
>
> <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211129223116.png" alt="image-20211129223116017" style="zoom:80%;" align="left"/>
>
> 这样做的好处是只需要移动一个元素。
>
> 但是显然，现在的堆不满足有序性，我们需要调整。
>
> ---
>
> 调整的思路是：
>
> parent 指向 space ，child指向parent较大的子节点 space = max(elements[child],temp)
>
> 循环的条件是 parent有child: parent*2 <= size	
>
> ---
>
> 实际过程：
>
> ![temp](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211130152923.png)
>
> 图一 把58(逻辑上)删除(58要么被max(44,31)覆盖)，parent = 1 child =2,(25<44 child不变) ，将max(elements[child],temp) = 44 填入space. 
>
> parent 1 =  child 2 
>
> 图二 parent = 2 ,child = 4,(4 == size 没有右儿子) ， parent指向的44要被max(elements[child].temp) = 36 覆盖。
>
> 图三 parent = 4 , 4 *2 > 4 循环结束 elements[parent] = temp； 
>
> 最终如图四 ， size = 4 size[5] 的数据没有意义，不需要覆盖为0；
>
> 如果图1到图3的过程中，出现 max(elements[child].temp) = temp ，循环结束了 执行 elements[parent] = temp； 



```JAVA
/**
     * 返回最大值
     */
public int remove() {
    int maxVal = arr[1];

    if (!isEmpty()) {

        // 将val移动到root位置
        int val = arr[size--];
        int space = 1;
        // space向下沉到正确的位置(其他元素的位置都正确)
        // 在空位的左右子节点中选择较大的移动到空位,直到space大于子节点

        while (space * 2 + 1 <= size && val < Math.max(arr[space * 2], arr[space * 2 + 1])) {

            // 左结点更大，将左节点移动到space
            if (arr[space * 2] > arr[space * 2 + 1]) {
                arr[space] = arr[space * 2];
                space = space * 2;
            } else {
                arr[space] = arr[space * 2 + 1];
                space = space * 2 + 1;
            }
        }

        // 位置调整好后 填入val
        arr[space] = val;
    }
    return maxVal;
}
```

---

> 总结一下：插入删除操作的底层都是类似于冒泡。
>
> 只不过在树中相邻的元素是parent和child.
>
> 最大堆 root->end降序
>
> 当我们从root开始，向下过滤元素(即移动root的值temp到何时的位置)。
>
> 循环变量 i 初值为 1, parent = i,child = max(i\*2,i*2+1),space == parent == i
>
> 如果我们从end开始，向上过滤元素，此时 child = space
>
> 循环变量 i 初值为 size, child = i,parent = i/2 space == child == i



---

#### 创建最大堆

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211129205512.png" alt="image-20211129205512493" style="zoom:80%;" align="left"/>

> 在创建最大堆的时候需要对3个变量赋值
>
> - elements : 表示数组
> - size : 表示当前元素个数
> - capacity : 堆的容量 -- 实际就是数组的大小



以上是创建一个空的堆，如果已有n个元素，如何创建最大堆呢？有两种方式

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211130155420.png" alt="image-20211130155419975" style="zoom:100%;" align="left"/>

在删除操作中，我们学习了，如何在左右子树都是最大堆的情况下调整。

所以调整的思路是分治，先让左右子树调整为堆。



# 图(上)

> 之前我就做过笔记，但是丢了。

## 图的介绍

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029140017.png" alt="image-20211029140017202" style="zoom:80%;" align="left"/>



## 图的抽象数据类型

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029140243.png" alt="image-20211029140243915" style="zoom:80%;" align="left"/>

> 抽象数据类型有三要素
>
> - 类型名称
> - 数据对象集
> - 操作集



---

## 图的实现

### 文件流创建无向图

首先定义，Edge,Vertex两种数据结构

#### Edge

> * 实际存储的数据结构与边并不对于(我们不是把边这个对象存入邻接表)，那么创建Edge的意义何在？？
> * 1. 数据封装和接口设计：图插入边的时候我们约定传入的参数是边，而不是几个零散的变量，有利于接口的规范；
> * 2. 统一性：采用不同的方式表示的图虽然各种方法如initGraph()，insertEdge()的实现不同，但是由于图的统一概念，上层的类(各种图相关抽象概念)是统一的；

```JAVA
public class Edge {
    /**
     * 有向边<from,to>
     */
    protected int from, to;

    /**
     * 边的权重
     */
    protected int weight;

    public Edge(int from, int to, int weight) {
        this.from = from;
        this.to = to;
        this.weight = weight;
    }

    @Override
    public String toString() {
        return "Edge{" +
                "from=" + from +
                ", to=" + to +
                ", weight=" + weight +
                '}';
    }
}

```



#### Vertex

```java
public class Vertex {

    /**
     * 顶点编号
     */
    protected int index;

    /**
     * 顶点数据
     */
    protected String date;

    public Vertex(int index, String date) {
        this.index = index;
        this.date = date;
    }

    @Override
    public String toString() {
        return "Vertex{" +
                "index=" + index +
                ", date='" + date + '\'' +
                '}';
    }
}
```



#### FileGraph(抽象类)

使用流创建graph对象，在Constructor中定义创建图的流程(不涉及图的底层实现) 

```JAVA
public abstract class FileGraph {

    /**
     * 顶点数量
     */
    protected int vertexNum;

    /**
     * 边数量
     */
    protected int edgeNum;

    /**
     * 初始化子类的成员
     */
    public abstract void initChildrenFields();

    /**
     * 插入顶点
     */
    public abstract void insertVertex(Vertex v);

    /**
     * 插入边
     */
    public abstract void insertEdge(Edge e);

    /**
     * 打印图
     */
    public abstract void print();

    /**
     * 获取邻接点
     */
    public abstract List<Vertex> getAdjNodes(int vertexId);


    /**
     * 使用File创建图的流程，子类通过实现抽象方法，完成对象创建。
     */
    public FileGraph(File file) {
        try {
            // 读取文件流
            Scanner in = new Scanner(new FileInputStream(file));

            // 读取vertexNum edgeNum
            int vertexNum = in.nextInt();
            int edgeNum = in.nextInt();

            // 创建空图
            this.vertexNum = vertexNum;
            this.edgeNum = edgeNum;

            //  初始化变量(子类可能会需要这两个变量初始化他们自己的成员变量)
            initChildrenFields();

            //  插入顶点数据 -- 先插入顶点，不然使用邻接表的时候，AdjNode没地方挂
            for (int i = 0; i < vertexNum; i++) {
                //i是Vertex的索引
                Vertex vertex = new Vertex(i, in.next());
                insertVertex(vertex);
            }

            // 插入边数据 -- 默认无向图
            for (int i = 0; i < edgeNum; i++) {
                int from = in.nextInt();
                int to = in.nextInt();
                int weight = in.nextInt();
                Edge edge1 = new Edge(from, to, weight);
                Edge edge2 = new Edge(to, from, weight);
                insertEdge(edge1);
                insertEdge(edge2);
            }
        } catch (FileNotFoundException e) {
            System.out.println("未找到初始化文件 '" + file + "' ，请检查路径");
        }
    }
}
```



#### 图文件

```
4 4

A B C D

0 1 2
0 3 5
0 2 3
1 3 1
2 3 4
```



### 邻接矩阵(MapGraph)

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029140848.png" alt="image-20211029140848626" style="zoom:100%;" align="left"/>

> 基本思想是记录所有的边。
>
> 注意这个二维矩阵记录的只是边，顶点的信息需要一个额外的Vertex数组

#### 无权无向图的表示1.0(二维数组)

对于一个无权，无向图，可以如此表示

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029141036.png" alt="image-20211029141036456" style="zoom:150%;" align="left" />

观察这个图显然我们可以发现

1. 对角线上的数组元素为0：不存在自回路，自己到自己的距离是0
2. 上下是对称的：无向图，<A,B> + <B,A> ==> (A,B)

> <A,B> 表示从A到B的有向边，(A,B)则表示无向边 





#### 无权无向图的表示2.0(一维数组)

对于这样一个图，显然数组浪费了一般的空间，那该怎么办？

将二位数组一维化，定义映规则 K = F(i,j) 即将`arr2[i][j]`映射到 `arr1[k]`.

![image-20211029141640635](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029141640.png)

---

#### 有权图的表示

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029141826.png" alt="image-20211029141826706" style="zoom:50%;" align="left"/>

> 0肯定不行，o表示距离为0.两个不相邻的顶点的距离应该是无穷大。
>
> 可以定义一个不肯能存在的距离，即-1(-1的无符号整数也是int中的最大值).



#### 优点分析

![image-20211029142223790](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029142223.png)

> 因为数组可以被直接访问。与数组数据访问相关的都很容易实现。



#### 缺点分析

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029142430.png" alt="image-20211029142430892"  align="left"/>

二维数组统计边,需要遍历整个数组,大部分遍历到的都是-1(即不是边的顶点对)



#### 代码实现

```java
public class MapFileGraph extends FileGraph {
    /**
     * 使用数组存储顶点信息
     */
    String[] vertexInfos;

    /**
     * 使用二维数组存储边信息
     */
    int[][] weights;

    /**
     * 通过文件创建对象,传入自己的空参构造的graph
     */
    public MapFileGraph(File file) {
        super(file);
    }

    /**
     * 定义插入Vertex的实现
     */
    @Override
    public void insertVertex(Vertex v) {
        vertexInfos[v.index] = v.date;
    }


    /**
     * 定义插入Edge的实现
     */
    @Override
    public void insertEdge(Edge e) {
        weights[e.from][e.to] = e.weight;
    }

    @Override
    public void initChildrenFields() {
        vertexInfos = new String[vertexNum];
        weights = new int[vertexNum][vertexNum];
        // -1,表示没有边; 0表示自回路
        for (int i = 0; i < weights.length; i++) {
            for (int j = 0; j < weights[0].length; j++) {
                if (i == j) continue;
                weights[i][j] = -1;
            }
        }
    }

    @Override
    public void print() {
        for (int i = 0; i < vertexNum; i++) {
            for (int j = 0; j < vertexNum; j++) {
                String from = vertexInfos[i];
                String to = vertexInfos[j];
                int weight = weights[i][j];
                System.out.print(from + "与" + to + "，距离为" + weight + "       ");
            }
            System.out.println();
        }
    }

    @Override
    public List<Vertex> getAdjNodes(int from) {// 顶点编号

        List<Vertex> adjNodeList = new ArrayList<>();

        for (int i = 0; i < weights[from].length; i++) {

            int weight = weights[from][i];

            // 如果 weight[from][i]不是0/-1,说明存在边。
            // i对应的vertex就是from对应vertex的邻接点
            if (weight != 0 && weight != -1) {
                adjNodeList.add(new Vertex(i, vertexInfos[i]));
            }
        }

        return adjNodeList;
    }
}
```



### 邻接表(LinkedGraph)

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029142712.png" alt="image-20211029142712742" style="zoom:100%;" align="left"/>

> 从一维的角度去考虑两者的都是记录每一个节点VertexNode.的情况。
>
> 只不过邻接表二维上是所有节点(下标表示vertex对象)。
>
> 邻接矩阵二维上的是链表连接的AdjNode.



邻接表 表示图

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029143226.png" alt="image-20211029143226068" style="zoom:100%;" align="left"/>



#### java代码实现

> 定义两种类 VetexNode表示顶点，AdjNode表示邻点。

代码详见github  [AdjNode.java](https://github.com/kkddyz/learn-algorithm/blob/master/algorithm_ZJU/graph/AdjNode.java) [VertexNode.java](https://github.com/kkddyz/learn-algorithm/blob/master/algorithm_ZJU/graph/VertexNode.java)



```java
public class LinkedGraph extends FileGraph {
    /**
     * 邻接表实际上就是一个VertexNode数组
     */
    protected VertexNode[] adjList;

    public LinkedGraph(File file) {
        super(file);
    }

    @Override
    public void initChildrenFields() {
        adjList = new VertexNode[vertexNum];
    }

    @Override
    public void insertVertex(Vertex vertex) {

        // 创建VertexNode
        VertexNode vertexNode = new VertexNode(vertex.date, null);

        // 挂到对应的数组单元
        adjList[vertex.index] = vertexNode;
    }

    @Override
    public void insertEdge(Edge e) {

        // 创建AdjNode
        AdjNode newAdjNode = new AdjNode(e.to, e.weight);

        // 找到对应的vertexNode
        VertexNode vertexNode = adjList[e.from];

        // 插入到vertexNode后面
        AdjNode head = vertexNode.adjNode;
        // 插入链表
        if (head == null) {
            vertexNode.adjNode = newAdjNode;
        } else {
            // 使用头插法
            newAdjNode.next = head.next;
            head.next = newAdjNode;
        }
    }

    @Override
    public void print() {
        // 遍历VertexNode
        for (int i = 0; i < vertexNum; i++) {
            VertexNode vertexNode = adjList[i];
            String data = vertexNode.data;
            System.out.println("顶点" + data + "的邻接点有: ");

            // 遍历链表
            AdjNode cur = vertexNode.adjNode;
            while (cur != null) {
                System.out.println(adjList[cur.index].data + "距离为" + cur.weight);
                cur = cur.next;
            }

        }
    }

    @Override
    public List<Vertex> getAdjNodes(int vertexId) {

        List<Vertex> adjNodeList = new ArrayList<>();

        // 1. 找到对应的VertexNode
        VertexNode vertexNode = adjList[vertexId];

        // 2. 将VertexNode跟着的AdjNode封装成Vertex
        AdjNode adjNode = vertexNode.adjNode;
        while (adjNode != null) {
            // 邻接点的数据要到对应的vertexNode中寻找
            Vertex v = new Vertex(adjNode.index, adjList[adjNode.index].data);
            adjNodeList.add(v);
            adjNode = adjNode.next;
        }

        return adjNodeList;
    }
}
```



#### 优缺点分析

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029143424.png" alt="image-20211029143424411" style="zoom:80%;" align="left"/>



## 图的遍历

### DFS

#### 伪码描述

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029151925.png" alt="image-20211029151925903" style="zoom:80%;" align="left"/>

> visited数组记录顶点是否被访问过。
>
> 注意这个递归是没有回调的。
>
> 遍历的策略是一旦没被访问过就变更当前位置。

#### 复杂度

若有N个顶点，E条边，时间复杂度是：



首先我们需要明确需要判断的语句

1. `visited[v] = true` 

   - 都是N次

2. `for( V的每个邻接点 W)`

   如果是数组，对于每个V都需要N次遍历数组(访问一行)，一共是n^2次。

   如果是链表，对于每个V只需要常数次，一共2E次(无向图)。

综合来看复杂度如下：

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029154109.png" style="zoom:100%;" align="left" />

---

### BFS

#### 伪码描述

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029153249.png" alt="image-20211029153249401" style="zoom:80%;" align="left"/>

> 语言描述 
>
> 1. 将第一个顶点压入队列
> 2. 循环处理队列，直到队列空。
> 3. 处理过程：
>    1. 每次抛出一个顶点V，标记为访问。
>    2. 压入V所有未被访问过的邻接点W.



#### 复杂度

和DFS一样

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029154109.png" style="zoom:100%;" align="left" />



### 非连通图的遍历

#### 连通的相关定义

连通：如果V->W存在一条(无向)路径，则称V和W是连通的。

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029155334.png" alt="image-20211029155334515" style="zoom:67%;" align="left" />

简单路径：不存在回路。

回路：起点等于终点的路径。

连通图：图中任意两个顶点均连通。



#### 无向图的连通概念

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029155647.png" alt="image-20211029155647901" style="zoom:67%;" align="left"/>



<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029160025.png" alt="image-20211029160025585" style="zoom:80%;" align="left"/>

> 左边是图，右边是子图(选出一些边一些顶点)。
>
> BCD那个不是连通分量，因为不满足极大顶点数



#### 有向图的连通给概念

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029160526.png" alt="image-20211029160526928" style="zoom:80%;" align="left"/>

> 因为D哪里也不能去，所以是单独的一个强连通分量。

---

#### 遍历方式

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211029160903.png" alt="image-20211029160903909" style="zoom:80%;" align="left"/>





----

# 图(中)

## 最短路径问题

### 问题描述

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030092633.png" alt="image-20211030092633147" style="zoom:80%;" align="left"/>



### 无权图的Shortest Path算法

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030094819.png" alt="image-20211030094819707" style="zoom:100%;" align="left"/>

> 通过一个二维数组模拟图。
>
> 一般的算法题，都会问在数组中A->B的最短路径。
>
> 基本思路从S开始BFS，在dist数组中更新距离。





### 有权图的ShortestPath算法

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030102210.png" alt="image-20211030102210270" style="zoom:80%;" align="left"/>

![image-20211030103602237](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030103602.png)

> 假设存在w使得s->w->v的距离最短，显然有dist[w] < dist[v]，但是w没有被收录而v被收录，说明dist[w] > dist[v]，两者矛盾。
>
> 
>
> 如果收录v使得s->w变短，那么必然是v与w直接相连。
>
> 假设v与w不直接相连，存在c使得 v->c->w最短，那么dist[c]>dist[v]。
>
> c一定在v后面被收录，但是这不符合dist的规则，dist[w]的经过节点一定已经被收录，所以不可能出现c在v后面。

算法的核心就在于*以递增的顺序收录节点V*，那么问题的关键就是保证收录的节点的dist一定是还未收录的最短的。



每次收录的v只会影响到它的邻接点，程序只需要更新它邻接点的dist值。

`dist[w] = min{dist[w],dist[v]+<v,w>的权重}` -- 递推表达式。



如何保证递增 --> 每次收录最小的。最小的是从边缘的扩展中选择的。

--> 如何保证每次选择最小的之后更新后的最小值一定是真正最小的。



v1是唯一的边缘节点，换句话说是最小的，任何不经过v1的节点都不是未收录的最小的节点。

更新v1的邻点v4,v2后，v4就是最小的。不更更新v2是因为v2还没有被收录。

![image-20211030105854541](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030105854.png)



![image-20211030110255040](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030110255.png)

更新v4，假如存在0.5，那么显然v2就不是最短路径了。



这个算法的本质是递推，依次找到对应的最小路径。

每次更新收录的元素是因为，其他的都还没有被收录，比如这里的v2,它已经出现在dist表中，但是不是最短的路径，所以更新v2的邻点之后不能保证是最短的，只能更新v4，因为此时确定最短的只有v1，v4。



贪心策略的一种，每次收录一个最短的路径，通过递推的方式确定。



---

![image-20211030125353503](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030125353.png)

> 语言描述是
>
> 1. 一开始将源点收录，更新dist，与path
> 2. 然后每一轮选出当前dist的最小的vertex，收录，然后更新它相邻的顶点
> 3. 直到所有顶点都被收录。



----

### 多元最短路径算法

![image-20211030155511012](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030155511.png)

> 相比于Dijkstra Floyd对于稠密图效果更好

![image-20211030160516569](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030160516.png)



![image-20211030160655509](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030160655.png)

> 初始化的D-1就是邻接矩阵，每一次考虑加入一个节点是否会改变某两个点之间的最短路径。



![image-20211030160857165](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20211030160857.png)

> 如果存在k使得`D[i][j]` 更短
>
> 当k = i或者k= j，不等式显然是不成立的

---

# 散列表

场景引入

编译期需要管理所有变量，是否可以使用AVL(二叉平衡树)来管理？？
BST的基本特点：比较，而字符串的比较效率很低。

处理的思路 ：将字符串转换为数字，这个比较就很快。



## 散列表基本实现

### 抽象数据类型

![image-20220408143800029](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220408143800.png)





### 装填因子 && Rehashing

![image-20220408144021440](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220408144021.png)

> 装填因子用于衡量冲入产生的概率，状态因子越接近1，越有可能产生冲突。



当装填因子达到阈值threshold，需要扩容table，进行rehashing

![image-20220408151216291](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220408151216.png)





## 冲突处理

### 开放地址法(不是重点)

![image-20220408144514382](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220408144514.png)



#### 线性探测

![image-20220408145421875](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220408145421.png)

##### 聚集现象

在过程中可以发现，如果散列值集中在某个位置，会导致冲突越来越多。

比如这里的30，由于之前已经有多个元素散列值为7，导致插入的复杂度呈线性增长。



##### 时间复杂度分析

![image-20220408145801535](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220408145801.png)

> 计算ASLs的方法是对散列表中存在的元素进行find操作，求均值。
>
> 
>
> ASLu 不是枚举所有不存在散列表的数，而是每一个位置假定一个不存在的数。
>
> 比如散列值为0，查找22，记录一直找到空位需要的次数。
>
> (为什么空位停止，因为根据开发地址法，如果冲突会将元素后移)

---

#### 平方(二次)探测

 <img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220408150511.png" alt="image-20220408150511382" style="zoom:80%;"/>

##### 问题 ：无法探测到所有空间 

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220408150634.png" alt="image-20220408150634774" style="zoom: 67%;" align="left"/>

> 在已经插入5，6，7的前提下，插入11会出现：虽然有空位，但是一直探测不到的情况

<img src="https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220408150739.png" alt="image-20220408150739880" style="zoom: 67%;" align="left"/>





#### 双散列

![image-20220408150926059](https://kkddyz-oss-image-hosting-service.oss-cn-hangzhou.aliyuncs.com/image/20220408150926.png)





### 链地址法

很简答，没有啥内容。
